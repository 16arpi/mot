
프로그래밍 언어

--
* 소프트웨어
* 프로그래밍 언어

--

FSM · 푸시 다운 · 튜링 머신(폰노이만 구조) · 정규 표현식 · 콘웨이의 생명 게임 · 형식 언어
계산 복잡도 이론
--
데이터 압축(무손실 압축 포맷 · 손실 압축 포맷) · 채널 코딩(채널 용량) · 알고리즘 정보 이론(AIT) · 양자정보과학
프로그래밍 언어 이론

프로그래밍 언어(함수형 언어 · 객 체 지향 프로그래밍 · 증명 보조기) · 메타 프로그래밍 · 유형 이론 · 프로그래밍 언어
의 미론 · 파싱 · 컴 파일러 이론
--
수학(해석학 · 이 산수학 · 수리 논리학 · 선형 대수학 · 미적분학 · 미분방정식 · 대수학(환론 · 범주론) · 정수론) ·
이론 컴퓨터 과학 · 암호학 · 전자공학 · 언어학(형태론 · 통사론 · 의 미론 · 화용론 · 음운론) · 인지과학
하드웨어 구성
--
논리 회로(보수기 · 가산기 · 논리 연산 · 불 대수 · 플립플롭) · 정보 이론 · 임베디드 시스템 · 운영 체제 ·
데이터베이스 · 프로그래밍 언어{컴파일러(어셈블러 · JIT) · 인터프리터 · 유형 이론 · 파싱 · 링커 · 난해한
프로그래밍 언어 } · 메타데이터 · 기계학습 · 빅데이터 · 폰노이만 구조 · 양자컴퓨터 · 행위자 모델 · 인코딩(유니코드 ·
MBCS) · 네트워크 · 컴퓨터 보안 · OCR · 슈퍼컴퓨터 · 튜링 머신 · FPGA · 딥러닝 · 컴퓨터 구조론 ·
--

공학 언어

수식 · 화학식 · 명제 논리 · 술어 논리 · 프로그래밍 언어 · 로 지반 · 링 코스 · 이쓰쿠일 · 도기 보나 · 보아 보무
국제 보조어
--
노시로 어 · 링 구아 프랑카 노바
예술어/가공의 언어

--

프로그래밍 사이트 선정 프로그래밍 언어 순위 목록

--

스펙트럼 부문 상위 10개 프로그래밍 언어

직업 부문 상위 10개 프로그래밍 언어
1
--

2024년 Stackoverflow 설문조사 기준 인기 상위 25개 프로그래밍 언어
1
--

2024년 8월 기준 검색어 점유율 상위 20개 프로그래밍 언어
1
--

2024년 8월 기준 검색어 점유율 상위 20개 프로그래밍 언어
1
--

프로그래밍 언어 목록 · 분류 · 문법
1. 개요2. 등장 배경과 역사3. 구조 4. 분류
4.1. 수준 4.2. 해석 방식으로 분류 4.3. 메모리 관리 방식으로 분류 4.4. 타입 시스템 4.5. 프로그래밍 패러다임
4.5.1. 명령형 언어
4.5.1.1. 절차적 언어 4.5.1.2. 객체 지향 언어
4.5.2. 선언형 언어
4.5.2.1. 함수형 언어4.5.2.2. 논리 프로그래밍 4.5.2.3. 반응형 프로그래밍
4.6. 특수 목적 언어
5. 회화 언어와의 관계 6. 개발툴7. 예제
7.1. 난해한 프로그래밍 언어의 예제
8. 오해9. 기타 10. 둘러보기
--
programming language
기계(컴퓨터)에게 명령이나 연산을 시킬 목적으로 설계되어 기계와 의사소통을 할 수 있게 해주는 언어를 뜻한다. 그 결과, 사람이
원하는 작업을 컴퓨터가 수행할 수 있도록 프로그래밍 언어로 일련의 과정을 작성하여 일을 시킨다. 쉽게 말하면 컴퓨터를 이용하기
위한 언어이다. 프로그램을 작성하는데 기본이 되고, 이 프로그램은 논리 연산의 집합이기 때문에 수리 언어의 일종으로 보는 시각도
있다.
컴퓨터보다 먼저 등장하였으며 본격적인 연구는 1930년대 즈음부터 수학자들에 의해 기계적으로 계산 가능한 함수에 대한 연구가
진행된 데에서 비롯되었다. 그 결과 기계가 이해할 수 있는 언어가 탄생했으며, 바로 이 기계가 계산 가능하고 이해 가능한 언어를
실행하는 기계로 언어보다 나중에 발명된 것이 바로 현대적 의 미의 컴퓨터이다.
이 언어들은 사람이 이해하기 쉽게 만든 언어로 실행 전 컴파일러를 통해 기계어로 컴파일 된 후 실행된다.[1]

--

역사를 잘 살펴보면 프로그래밍 비스 무리한 것을 만들고 했던 기인들이 종종 등장하지만, 프로그래밍 언어라는 본격적인 개념은 역시
수학에서 등장하였다. 쿠르트 괴델은 불완전성 정리를 증명하는 과정 중에 알고리즘을 추상화시킨 원시 재귀 함수(primitive
recursive function) 개념을 만들고, 이를 이용하여 증명에 성공하였는데, 수학적으로 본다면 이것이 최초의
프로그래밍 언어라 볼 수 있다.(굳이 따지자면 함수형 언어라 할 수 있다.) 그리고, 몇 년 후에 컴퓨터의 아버지라 불리는 앨런
튜링은 불완전성 정리를 보고 "어 이 거 내 방식대로 증명해 볼 수 있겠는데?"라고 생각하며 연구를 하는데, 여기서 이
--
동치라고 그냥 간주할 것을 제안하며, 이것이 그 유명한 처치의 명제(Church's Thes is)[5]이다.
이렇게 수학 쪽에서 프로그래밍 언어에 대한 개념적인 기초가 닦아지는 동안, 역시 수학자인 폰 노이만은 그것들을 이용하여 실제
컴퓨터를 만들기 위한 폰 노이만 구조를 만든다. 그렇게 전자 쪽과 결합을 하면서 현대 컴퓨터의 원형이라고 할 수 있는 물건이
--
따라서 뭔가 동작을 시키기 위해서는 이러한 제어 신호를 사람이 직접 작성해야 됐는데, 초창기에는 그 0과 1의 제어 신호를
사람이 직접 작성하는 형태의 기계어가 사용되었다. 이 기계어는 항목에서 볼 수 있듯이, 이 쪽 분야에서 가장 원시적인 언어로
기계는 바로 이해할 수 있는데 사람은 도저히 이해하기도 어렵고 알아보기도 힘들어서 결국 사람이 읽기 편하도록 기계어와 특정
--
난해하였고, 컴퓨터 보급과 함께 프로그램 수요가 늘어나는데 어 셈블리어의 생산성은 매우 낮 기 때문에, 조금 더 프로그램을 짜기
쉬운 언어들이 등장하기 시작하였다.
초창기에 프로그래밍 언어들은 컴퓨터 성능의 한계로 많은 제약이 따라 붙었고, 어 셈블리어 성격이 어느 정도 남아 있었다. 그럼에도
어셈블리어에 비하면 읽기가 편했고 이해하기도 훨씬 쉬웠다. 그리고 컴퓨터 보급과 성능 발달에 맞물려 그 동안 걸려 있던 제약
조건들도 하나씩 사라지고, 보다 사람이 읽기도 쉽고, 이해하기도 쉽고, 작성하기도 쉬운 프로그래밍 언어들이 속 속 등장하였다.
다만 어차피 컴퓨터가 이해할 수 있는 언어는 기 계어뿐이기 때문에 사람이 하기에 편해졌다는 것 뿐이지 실제 그 뒤에서 이루어지는
작업은 훨씬 더 복잡해지고 있다.
정리하자면, 기계에게 편한 언어는 속도가 빠르지만 사람이 보고 다루기 불편해서 생산성이 떨어진다. 반면 사람에게 편한 언어는
속도는 느리지만 이해하기 쉽고 생산성이 높다는 상관 관계가 성립한다.
단, 여기에 함정이 있는데 기계어로 짠 발적 화 코드와 자바로 짠 최적화 코드의 수행 속도를 비교한다면 당연히 자바 쪽이 빠르다.
그러니까 기 계어를 사용한 다 해도 그걸 다루는 프로그래머가 기계의 특성을 훤히 꿰고 있지 않으면 다른 고급 언어를 사용한
결과물보다 느려질 수도 있다는 얘기다. 그래서 몇몇 개발 관련 서적에서는 최적화나 성능 튜닝한답시고 기계어나 어셈블리어를
--
배열을 더한다거나)가 생길 수 있는데 애초에 이런 코드를 만들지 않는 능력이 더 중요하다.
자바 언어를 많이 사용하게 된 이유는 다름 아니라 C 언어의 호환성 때문이라고 한다. C 언어의 단점이 유닉스에서 C 언어로 만든
코드가, 윈도우 운영체제에서는 작동을 안 했다고 한다. 더 큰 문제는 유닉스도 버전이 다양해서 유닉스 운영체제끼리 호환이 안
된다는 거다. 이런 호환성 문제를 해결한 언어가 자바다 보니, 자바 언어를 많이 사용하게 됐다고 한다.[7]
여담으로 난해한 프로그래밍 언어보다는 어 셈블리어가 훨씬 읽기 쉽다...

--

프로그래밍 언어의 표기는 구 문론(syntax)과 의 미론(semantics) 두 가지로 이루어진다. 구문이란 것은 언어의 외형적인
표기 방법을 일컬으며, 의 미론은 구문이 내포하고 있는 의미, 즉 그 코드가 수행하는 작업을 뜻한다. 구문이 문법에 비유된다면
--
연산자(operator), 예약어(reserved keyword)[9] 등이 있다.
대부분의 일반적인 프로그래밍 언어는 이런 토 큰들이 영어(정확히는 미국식 영어)로 되어 있다. 물론, 창조(프로그래밍 언어)나
씨앗(프로그래밍 언어) 같은 예외도 있긴 하다.

--

* 프로그래밍 언어/종류
* 한글 프로그래밍 언어

--

추상화가 거의 되지 않아서 컴퓨터가 이해하기 쉬운 언어를 저급 언어, 고도로 추상화해 사람이 이해하기 쉽지만 컴퓨터가 이해하려면
복잡한 번역이 필요한 언어를 고급 언어라 한다.
* 저급 언어
+ 기계어, 어셈블리어[10]
* 고급 언어
+ 위의 두 언어를 제외한 모든 언어

--

크게 AOT 컴파일 언어, JIT 컴파일 언어, 그리고 인터프리터 언어로 분류할 수 있다. 이 분류는 정확히 말하면 언어의
분류가 아니라 언어 구현체의 분류로, 언어 명세가 어느 한 쪽을 완전히 배제한 형태가 아니거나 다른 특별한 이유가 있지 않는
이상 대부분의 언어는 이론상 어떤 식으로든 구현 가능하다. 더불어, 산업 현장에서 널리 쓰이는 언어는 기 본적으로 컴 파일 되어
실행된다고 보면 된다. 아래의 구분은 언어의 대표 구현체를 따른 것이고, 결코 언어 자체의 분류가 아님에 유의할 것. 예를
들면, C 언어라고 항상 AOT 컴파일 되는 것이 아니며 [11], Java라고 항상 JIT 컴파일 되는 것도 아니며 [12],
OCam l[13]과 Erlang[14] 등의 언어는 아예 기 본 구현체에 둘 다 포함시켜서 배포한다.
* AOT(Ahead Of Time) 컴파일 언어 : C 언어, C++, Rust, 파스칼, Haskell 등이 포함된다.
소스 코드를 미리 기계어로 번역[15]해서 실행한다. 미리 컴 파일 하더라도 가비지 컬렉션의 유무에 따라 실행 속도가 차이가
나 기도 한다. 일반적으로 C 계열의 언어들의 런타임 퍼포먼스가 좋기 때문에 AOT 컴파일 된 언어들이 근본적으로 다른
구현 방식에 비해 빠르다는 착각을 하는 경우가 많으나, AOT 컴파일 되었다고 실행 성능이 좋을 것이라고 지레짐작 해서는
--

* JIT(Just-In-Time) 컴파일 언어 : 대부분의 언어가 여기에 속한다. Java 및 JVM 언어[17],
JavaS cript 및 WebAssem bly[18], C# 및 CLR 언어[19] 등의 언어들은 기본 구현체가 JIT
컴파일러이다. 이 언어들은 대부분 바이트코드를 생성하는 1차 컴파일러, 그리고 1차 컴파일러가 생성한 바이트 코드를
실행하는 가상머신(VM)으로 이루어져 있다. 이 가상머신 안에 바이트 코드에 대한 인터프리터, 바이트 코드를 기계어로
컴파일하는 JIT 컴파일러와 GC를 비롯한 런타임이 포함된다. JVM과 CLR(Common Language
Runtime), CP ython은 1차 컴파일러가 생성한 바이트 코드 파일들을 배포에 활용하지만, 모든 언어가 그런 것은
아니다. 또한, JIT 구현체는 동일한 언어의 AOT 구현체에 비해 유연성이 높은 경우가 많다. 예를 들면 Java에서는
JIT 컴파일할 때에는 가능한 동적인 클래스 로딩이 SubstrateVM을 통한 AOT 컴파일 시에는 불가능하고,
--

* 인터프리터 언어 : 소스 코드를 한 줄 한 줄 읽어 그때 그 때마다 번역해서 수행한다. BASIC이나 셸 같은 언어가 이런
형태이다. 소스 코드를 한 줄씩 읽어서 수행하기 때문에, 대체로 AOT 컴파일 언어나 JIT 컴파일 언어에 비해 성능이
떨어지는데, 2010년대 들어서 인터프리터 엔진에도 JIT 기법이 도입되었다. Python[21], Ruby[22],
--
같이 구현체가 매우 가볍고 간단할 필요성이 있을 때, 또는 구현체를 충분히 빠르게 만들도록 노력을 들이지 못한 수많은
마이너 언어들이 인터프리터를 통해 작동한다.

--

크게 비관리 언어와 관리 언어로 분류할 수 있다.
* 비관리 언어(Unmanaged Language) : 동적 할당된 메모리의 해제가 자동으로 이루어지지 않으며, (주로
포인터를 이용한) 메모리 직접 접근이 가능한 언어이다. Bare Metal Language라고도 하며, 대표적으로는 C,
C++ 등이 있다. 수동 기계 제어가 가능한 만큼 프로그래머의 최적화 실력에 따라 높은 퍼포먼스를 낼 수 있지만, 반대로
생각하면 그렇기 때문에 메모리 관리를 제대로 하지 않을 시 프로그램이 망가질 가능성이 커서 관리 언어에 비하면 생산성은
떨어진다.

* 관리 언어(Managed Language) : 동적 할당된 메모리의 해제가 가비지 컬렉터(Garbage
Collector)에 의 해 자동으로 이루어지며, 메모리 접근에 대한 부분을 추상화시켜 직접적인 기계 제어를 기본적으로
차단한다. 대표적으로는 Java, C#, Python, Go 등이 있다. 메모리 관리를 언어 차원에서 책임져 주기 때문에
상대적으로 생산성은 높지만, 메모리에 직접 액세스할 수 없으므로 비관리 언어에 비해 성능 면에서 손실이 있다.

--

* 정적 타입 언어 : 자료형(Type)이 고정돼 있는 언어. C, C++, Java, C# 등이 여기에 해당된다.

* 동적 타입 언어 : 타입이 실행 시간에 결정되는 언어. 실행하기 전까지는 특정 식의 타입을 알 수 없다. Python,
JavaS cript, Ruby 등이 여기에 해당된다.
--
고정된 타입을 가지며 암시적으로 마구 변환되지 않는다. 다만 명시적인 조건 없이도 공통의 인터페이스를 구현하는 것들을 넣어주면
동작하게 되어 있다. 이런 개념은 "덕-타이핑"이라고 하고 동적 타입만의 특성은 아니며 정적 타입 언어에서도 구현이 가능하다.
단지 정적 타입 언어들이 추구하는 방향이 덕 타이핑과 맞지 않는 경우가 많기 때문에 잘 안 쓸 뿐이다.
동적 타입 언어 중에서 자바스크립트는 암시적으로 자료형을 마구 변환해주지만 기능보다는 설계 결함으로 간주된다. 정적 타입 언어
중에서는 C가 이런 무분별한 암시적 형 변환으로 악명 높다. 알아서 변환해준다는 게 좋게 들릴지 몰라도 막상 써보면 괴로워지는
경우가 더 많다.
정적 타입 언어가 별 거 아닌 것처럼 느껴질 수도 있지만 실은 프로그래머들을 짜증나게 하는 주범이 바로 형 변환(Type
casting)이기 때문에 동적 타입 언어는 이런 점에서 매우 강점을 가진다. 특히 객체 지향 언어에서는 동적 타입 및 그것의
일반 화 버전이라 할 수 있는 덕 타이핑(Duck typing)이 프로그래머에게 수많은 혜택을 준다. 예를 들어 오리라는 타입과
닭이라는 타입이 있고 둘 다 날아오르는 기능이 있다면 정적 타입 언어에서는 상위 인터페이스를 추출하는 등의 부가 작업이 필요한데
덕 타이핑을 지원하는 언어에서는 그냥 넣어버리면 알아서 난다. 물론 단점도 있는데 고래 같이 못 나는 타입을 집어 넣으면
실행시간 오류(런타임 에러)를 뱉어버린다는 것이었지만 정적 타입 언어는 이런 문제가 없다고 알려져 있지만 거짓말이고 정적 타입
언어도 닭은 닭인데 통닭 같이 못 나는 타입을 집어넣는 바람에 (기술적으로는 해당 메서드가 구현이 안 된 객체) 런타임 에러가 나올
수 있다.
그러나 이건 현실을 전부 고려하지 않은 반쪽짜리 시각이고, 요즘은 정적 타입 언어가 동적 타입 언어보다 훨씬 생산적이고 오류가
날 가능성을 줄여준다는 점이 정설로 굳어지고 있으며, 코딩 경력이 주니어만 넘어가더라도 프로그래머가 정적 언어를 선호하는 경향이
눈에 띄게 늘어난다. 당장 동적 타입 언어로 유명한 파이썬과 자바스크립트[24]가 정적 타입으로 옮겨가려는 움직임을 보이는
것으로 알 수 있지 않을까? 위에 있는 예시는 거의 모두 현실과는 동 떨어진 예제와 설명이다. 위에서 든 상위 인터페이스 추출이나
메서드 미 구현 문제는 정적 타입의 문제가 아니라 객 체지향의 문제로, 정적 타입과 하 등 상관없고 오히려 동적 타입으로 객 체지향
개발을 하려고 할 때 더 흔히 일어나는 문제들이다. 강하고 안전한 정적 타입 시스템을 지원하는 언어는 대부분의 일상적 프로그래밍
오류를 미연에 방지해준다. 가령 가장 기본적인 동작인 함수 호출의 사례만 봐도 이러한 측면을 쉽게 이해할 수 있다. 동적 타입
언어는 그 어떤 쓰레기 값을 인자로 사용해서 호출해도, 심지어 아예 인자의 갯수마저 틀려버려도 그 호출 코드를 런 타임에 아무
의심 없이 실행해버리고 예상치 못한 동작을 하며 디버깅에 애를 먹이기 일쑤다. 하지만 정적 타입 언어는 잘못된 호출을 하고 있다고
컴파일 시에 오류를 친절히 알려준다[25]. 하스켈을 비롯한 강-정적 타입 언어 사용자들이 "컴파일이 된다면 버그는 없다"고 하는
말이 빈 말이 아닌 것이다.
--
제대로 활용하느냐 못하느냐에 따라 개발 기간이나 유지 보수성이 천지 차이로 벌어진다.
참고로 하스켈(Haskell)은 정적 타입 언어다. 그런데도 하스켈 코드에는 형 변환 연산자가 없다. 이게 어찌된 일이냐 하면
하스켈 언어는 정적 타입 언어이지만 강력한 타입 추론 기능을 내장하고 있어 형 변환을 언어 차원에서 자동으로 해 준다. 동적 타입
언어 역시 자동 형 변환을 제공하는데 무슨 차이가 있냐면 그 형 변환을 런 타임에 하느냐 컴파일 타임에 하느냐의 차이다. 즉 버그가
발생하는 시점을 런 타임(사용할 때)에서 컴 파일 타임(만들 때)으로 끌어당긴다. 타입 추론 엔진은 딱히 하스켈 같은 선언형,
함수형 언어에만 도입할 수 있는 건 아니므로 신형 설계가 적용된 언어라면 명령형, 객 체 지향 언어라도 타입 추론을 할 수 있다.
단지 정적 타입 언어로 유명한 C나 자바에 타입 추론 엔진이 없을 뿐이고, C#이나 Kotlin[27] 등의 고 생산성 정적 타입
언어들은 얼마든지 타입 추론을 지원하고 있다. 여기서 타입 추론은 묵 시적 형 변환과 동의 어가 아니다. 겉으로 보이는 건 묵 시적
형 변환하고 똑같다.
--
변환이 되는 게 아니라 컴 파일 오류를 내뱉는다. 하스켈이나 ML에 쓰인 타입 추론 엔진은 Hindley-Milner 시스템이라고
불리는데, 명령형 언어 중에서는 Rust가 이를 적용했었다.(현재는 아님.)

--

4.5.1. 명령형 언어[편집]

명령형 언어(Imperative Language)는 프로그램이 어떻게 작업을 수행할지를 표현하는 프로그래밍 언어이다. C,
Java, C++, Fortran 등의 언어가 여기에 속한다. 명령형 언어는 다시 절차적 언어와 객 체 지향 언어로 나뉜다.

4.5.1.1. 절차적 언어[편집]

--
Procedural Language. 프로그램을 프로시저(Procedure)의 단위로 나누어 문제를 해결하는 방식으로 작성하는
프로그래밍 언어. 대표적인 언어는 C와 Pas cal. 종종 객 체지향 언어의 상대적 개념으로 절차 지향 언어란 말을 쓰기도
하는데, 이는 객 체지 향 언어가 등장한 이후에 나타난 것으로 보인다. 이름의 절차는 '명령이 순차적으로 실행되어야 함'을 지칭하는
절차가 아니라, 'Proc edure 단위로 특정 명령을 절차화해야 함'을 말한다. 즉 어셈블리어 등의 순차 제어 개념에서 벗어나
명령을 함수 단위로 묶어 관리함을 말하는 용어다.
애초에 C++나 Java 등의 객 체지 향 언어가 널리 알려지기 전에는 C 나 Pas cal을 절차 지향 언어라고 부르지는 않았다.
그보다는 구조적 프로그래밍 언어란 말이 C나 Pas cal을 가리키는 말이었다. C++, Java 같은 객 체지 향 언어는 객 체 개념
구현 자체가 프로그램 언어 개발의 지 향점 중 하나였지만, C 나 Pas cal 등의 언어는 절차 지향을 목표로 개발된 언어가
아니다. 따라서, 객 체지향을 구현하지 않은 기존 언어를 가리키는 말로 절차 지향 언어보다는 절차적 언어가 적합한 용어 일 것이다.

4.5.1.2. 객체 지향 언어[편집]

--
참고하십시오.
객체 지향 언어는 프로그래밍을 함에 있어서 데이터와 그 데이터를 처리할 메소드를 한데 묶어 객체를 만들고 객 체들을 조립하는 것을
목표로 한 언어들을 말한다. 대표적으로 Java와 C++가 여기에 속한다. 객체 지향 언어의 특징은 추상화, 캡슐화, 상속성,
다 형성이 있다. 추상화는 외부 인터페이스만 제공하고 객 체 내부를 숨겨서 어떻게 일을 하는지 몰라도 결과를 내보낸다.[28]
--

4.5.2. 선언형 언어[편집]

선언형 언어(Declarative language)는 명령형 언어와 대비 되는 개념으로, 함수형 언어와 논리 프로그래밍(Logic
programming) 등이 여기에 속한다. 현재 학계를 떠나 슬슬 업계 전반으로 확산되고 있다. 특히 신기술의 도입이 빠른 웹
앱 계열에서 선언형 스타일의 프로그램이 선호되고 있는데 JavaS cript 코드의 코딩 스타일이 점점 선언형으로 변화하고 있다.
선언형으로 기술하는 가장 유명한 라이브러리로는 제이쿼리(jQuery)가 있으며 앵귤러 JS(A ngul arJS)는 선언형 언어의
가장 최신 트렌드인 반응형 프로그래밍 개념을 도입하고 있다.(2-Way binding이라는 이름으로 소개하고 있다.)
순수 선언형 언어의 특징으로는 참조 투명성(referential transparency)[31]가 꼽힌다.
또한 선언형 언어에는 '지연 평가(Lazy evalu ation)'라는 강력한 특징이 있다. 계산을 필요한 그 순간이 올 때까지
미룬다는 개념인데, 이 개념은 선언형 언어에만 있다. 단 선언형 언어 전부가 지연 평가를 지원하는 건 아니다. 이 지연 평가
개념의 강력함은 무한을 다룰 때 나타난다. 예를 들어 입력 데이터로 자연수 전체의 집합을 정의해서 대입하는 게 가능하다! 명령형
언어에서는 무한을 대입하면 말 그대로 무한히 계산을 하기 때문에 프로그램이 무한 루프를 돌며 멈춰 버리지만 지연 평가를 지원하는
언어에서는 만 약 계산식의 마지막이 "...해당 리스트의 첫 5개를 출력." 하는 식으로 끝났다면 그 '첫 5개'를 찾아내기 위한
계산만을 수행하고 끝낸다. 예를 들어 "피보나치 수열의 10번째 항부터 30개 항을 출력하라"는 알고리즘을 구현할 때 명령형
언어라면 피보나치 수열을 생성하는 알고리즘 자체에 루프를 멈추는 코드를 삽입해야 하지만 지연 평가가 지원되는 선언형 언어의 경우
피보나치 수 열 알고리즘은 "제네레이터"로 만들어 무한 수열을 출력하게 하고 필터로 원하는 위치의 리스트를 뽑아주면 된다. 물론
--
멈춰 버린다. 피보나치 수열은 무한 수열이 기 때문에 "마지막"이 없기 때문.
선언형 언어가 아니어도 지연 평가를 구현하는 방법이 있긴 하다. 더 티 플래그(dirty flag) 기법이 대표적. 단지 언어에서
직접 지원하지 않을 뿐이다.

4.5.2.1. 함수형 언어[편집]

상세 내용 아이콘 자세한 내용은 함수형 언어 문서
를
--

명령형 언어가 튜링 머신에, 함수형 언어가 람 다 대수에 기반하고 있다면 논리 프로그래밍은 수리 논리학의 First ord er
logic(1차 언어)을 모델로 사용하는 프로그래밍 언어의 총칭이다.
사실 이 바닥의 알파와 오메가인 Prolog가 1차 언어에 기반하고 있기 때문에 이런 식의 정의가 많이 쓰이지만 실제론
Higher ord er logic, F-logic, linear logic 등 여러 가지 다른 논리를 사용하는 언어도 있고,
이것들도 대부분 Prolog에 기반하고 있는 경우가 많아서 다 논리 프로그래밍 언어라 한다.
Clause의 집합이 곧 프로그램이 되며, Clause는 이 쪽에서 가장 유명한 Prolog 언어를 예로 들면 아래와 같은
형식으로 정의된다.
--
이것은 If Body, then Head 즉, To solve Head, solve Body식으로 해석할 수 있다.
사실 일반 프로그래머 눈에 위의 함수형 언어보다 더더욱 괴악해 보이게 마련인데 그래도 튜링 컴플리트이며 C++ 등과 같은
General purpose 언어다.
함수형 언어에서 프로그램을 함수의 집합으로 보고 있다면 논리 프로그래밍에서는 프로그램을 공리의 집합으로 보고 있다고 이해하면
된다.
명령형 언어와는 거리가 멀지만 함수형 언어와는 의 외로 가까운 편이고 실제 코드도 꽤 비슷한 양상을 띈다.
실제 코딩시의 함수형 언어와 가장 큰 차이라면 아무래도 함수형 언어가 '함수'를 사용할 때, 논리 프로그래밍 언어에서는
'관계'(Relation)(수학적으로, 함수는 관계의 부분 집합이다.)를 사용한다는 부분이 가장 큰 차이 일 것이다.
--
예시가 데이터베이스 쿼리이다.
다만, Prolog는 논리 프로그래밍 언어지만, 순수 선언형 언어는 아니다.
Mercury라는 순수 선언형 논리 프로그래밍 언어도 있고 스페인에서 팍팍 밀어주는 Ciao도 순수 선언형 서브시스템을
지원한다.
이쪽 언어들은 Prolog를 제외하면 Prolog를 기반으로 해서 여러 가지 실험적인 확장을 시킨 것들이 많기 때문에 유저
매뉴얼이 곧 논문인 경우가 많고 수리 논리학 이론을 잘 모를 경우 접근하기 힘든 것들이 대부분이다.
--
Reactive programming. 데이터를 중심으로 사고하는 방식인데 같은 데이터 중심 시각의 OOP와 다른 점은 반응형
프로그래밍은 데이터의 흐름 즉 데이터 플로우(Data flow)에 더 관심을 갖는다. 반응형 프로그래밍 언어 중 가장 쉽게 볼
수 있는 것은 스프레드 시트 프로그램인 엑셀이 있다. 프로그래밍 언어는 모름지기 텍스트 편집기로 작성하는 거라고 따지고 싶다면
ReactiveX라고 하는 게 있다.
--
OOP나 함수형, 논리형 프로그래밍과 배척하는 관계는 아니라는 점에 주의. OOP도 세터(Setter)메서드에 적절한 처리를 해
주면 반응형으로 만들 수 있다. 다만 반응형 프로그래밍을 직접 지원하는 언어나 라이브러리는 그런 적절한 처리를 자동으로 해
준다는 차이가 있다.
--

4.6. 특수 목적 언어[편집]

* SQL - 관계형 데이터베이스에서 데이터를 조작하기 위해 사용되는 표준 언어로 여러 DBMS에서 지원한다.
* CUDA - 엔비디아 제 GPU를 제어하는 언어.
* Prolog - 논리 증명 언어
* Process ing - 그래픽스 처리를 위한 언어
* MATLAB - 공학용 시뮬레이션용 언어
* PHP - 웹 사이트를 만드는 데 특화된 언어
* Verilog, VHDL - 디지털 하드웨어의 설계, 시뮬레이션, 문서화를 위한 언어로, 반응형 프로그래밍에 속한다.
* Verilog-A - 아날로그 하드웨어 설계를 위한 언어

특수 목적 언어의 특징은 해당 분야에서는 뛰어난 생산성을 보인다는 것이다. 하지만 해당 분야를 벗어나는 순간 개발이
불가능해지거나 오히려 더 난해해진다. 때문에 이런 언어는 아무도 범용 프로그래밍에 사용하지 않는다. 예를 들어, SQL로는 당장
지원 DB 외의 파일 조작이 매우 어렵다. (SQLite에서는 아예 불가능하다.) 따라서 프로젝트 하나를 하는 데에도 알게
모르게 여러 언어를 써가며 개발하게 되며, 보통은 일반 목적 언어(보통 C, Java 등) 하나에 여러 특수 목적 언어를
물려가며 사용한다. 마크업 언어까지 감안하면 하나의 언어만으로 프로그래밍 하는 일은 초보적인 프로그래밍을 제외하고는 거의 없다고
봐도 된다.

5. 회화 언어와의 관계[편집]

--

프로그래밍 언어는 소프트웨어 개발이라는 한정된 목적으로 쓰이고, 일 생상활에서는 쓰이지 않는다. 또한 회화 언어보다 문법이
엄격하고, 2인칭이 존재하지 않는 등 얼핏 보면 일상적으로 쓰는 자연어와 괴리감을 느낄 수 있다. 이는 데이터의 기술을 주요
목적으로 하는 마크업 언어에서도 느낄 수 있는 분위기다.
하지만 자연어와 프로그래밍 언어의 관계는 상당히 밀 접하다. 그 예로 단어를 소리 단위로 쪼개는 음운론은 프로그래밍 언어로 치면
토큰 구성 이론과 같으며, 문장을 단어 단위로 쪼개는 통 사론은 프로그래밍 코드 형태로 쓰인 텍스트를 토 큰 단위로 쪼개는 컴 파일러
이론과 완전히 동일하다. 기계 번역도 사실 프로그래밍 쪽에서 컴 파일러, 인터프리터 등의 형태로 이미 적용되어 있던 것이 자연어로
옮겨간 것이다. 알 토네리코 시리즈의 휴므 노스어나 Ciel nos urge의 REON-4213처럼 프로그래밍 언어와 자연어를
접목하려는 시도도 있었으며, 로 지반 역시 비슷한 노력의 산물이다.
즉, 프로그래밍 언어와 자연어는 근본적으로 큰 차이가 없다. 애초에 프로그래밍 언어 역시 기계와의 ' 회화'를 위해 사람이 만들어
쓰는 말이며, 단지 기계도 청자(聽者)가 될 수 있다는 차이만 있을 뿐이다. 그렇기에 컴파일러가 발달하지 않았던 과거에는 존 폰
노이만처럼 기계어를 외국어 하듯 구사하는 사람이 많았고, 오늘날에도 언어학과에서 프로그래밍 언어를 가르치기도 한다. 게 다가
ChatGPT 같은 인공지능 언어 모델이 출현하며 프로그래밍 언어와 자연어 사이의 경계는 더욱 모호해지고 있다. 본래 언어
모델은 인간의 자연어를 이해하고 그에 맞는 답변을 내놓는 것이 목표였는데, 수많은 코드를 학습시키다 보니 프로그래밍 능력까지
덤으로 생겨버렸다. 프로그래밍 언어도 본질적으로는 언어라는 것을 보여주는 사례이기도 한데, 사실 자연어 처리 연구가 진척되면서
정설로 받아들여지고 있는 사실이기도 하다.
말만 익힌다고 끝나는 게 아니라는 점도 회화 언어와 프로그래밍 언어의 공통점이다. 어떤 회화 언어에 충분히 숙달됐더라도 현지
문화나 관습적 표현, 법규 등을 익혀야 그 언어를 사용하는 현지에서 원활하게 생활할 수 있듯, 프로그래밍 언어 역시 그 언어에
적용할 수 있는 방법론이나 개발 분야에서의 프로토콜 등을 지속적으로 이해해야 실무에서 살아남을 수 있다. 많은 코더들이 실무에서
좌절하는 이유가 여기에 있으며, 그렇기에 번역가도 프로그래머도 모두 평생 학습을 필요로 하는 직업이다. 실제로 이를 근거로
비트겐슈타인의 '언어 게임'과 연결해 중국어 방의 근본적인 한계를 지적한 논문도 존재한다.[33]
코더가 양산되는 이유를 이런 관점에서 살펴보면 양판소가 비판 받는 이유를 이해하기 쉽다. 다시 말해 프로그래밍은 소설 작법과 유사한
--
또는 문화 차이에서 발생한 오류로 볼 수 있다. MOTHER 2의 문사이드에서 나온 '예'와 '아니오'가 바뀐, 그래서 검은
닌텐도의 일환으로 평가받는 언어 활용은 프로그래밍으로 치면 하드웨어 결함으로 발생한 버그와 유사하다. 더욱 섬뜩한 예로, 잘못된
언어 활용으로 발생하는 갈등은 악성코드와 유사하다.
CC-white 이 문단의 내용 중 전체 또는 일부는
--
(이전 역사)
프로그래밍 언어론

프로그래밍 언어론
문서의 r14 판
--

상세 내용 아이콘 자세한 내용은 프로그래밍 언어/예제 문서
를
--

7.1. 난해한 프로그래밍 언어의 예제[편집]

상세 내용 아이콘 자세한 내용은 프로그래밍 언어/예제/난해한 프로그래밍 언어 문서
를
--

프로그래밍 언어에 관해 널리 퍼진 오해 중 하나는, '프로그래밍 언어만 알면 개발을 할 수 있다' 이다. 프로그래밍 언어는
이름대로 언어일 뿐이다. 즉 도구다. 이 도구를 이용해 유용한 프로그램을 개발하는데 필요한 지식과 기술은 별개로 공부해야 한다.
한국어를 할 수 있다고 누구나 소설을 쓸 수 있는 게 아니듯이 말이다.
이는 완전히 틀린 말은 아니지만, 현실적으로 프로그래밍 언어는 '명령'(A일 경우 B를 하라 등)을 추상화할 뿐이며 초보자가
이러한 작은 명령들을 가지고 고 수준의 프로그램을 제작하는 것은 바퀴를 재발명하는 일이 될 수도 있다. 실용적으로 사용되는 수준의
응용 프로그램(애플리케이션)을 제작하려면 단순히 언어만 배워서 끝이 아니라 적합한 프레임워크, 엔진 등과 여러 작업을 위한
라이브러리들, 넓게는 '자신이 무엇을 만들어야 하는지'에 대한 도메인 지식과 이를 어떻게 기술적으로 구현할지에 대한 소프트웨어
엔지니어링 지식이 필요하다.
예를 들어 백엔드 구축을 위해서는 각 언어별 웹 프레임워크가, 2D/3D 게임 개발을 위해서는 게임 엔진이, SSR 렌더링을
위해서는 템플릿 엔진(Jinja, Pug 등) 또는 관련 서버 사이드 언어(JSP, PHP 등)에 대한 지식이, CSR 렌더링을
위해서는 웹 프런트 엔드 프레임워크가, 모바일 개발을 위해서는 모바일 운영체제 별 API를 사용해야 한다.[34]
따라서 언어의 문법을 배우는 것은 실제 개발 생태계에서는 단지 기초에 불과 한 과정이지만, 그만큼 초보자들이 가장 먼저 접하는
부분이며 좌절하기도 쉬운 부분이기에 인터넷에서 자신이 C 언어를 안다고 스스로 해커를 자처하는 등의 오해가 흔히 발생하는 것이다.
마찬가지로 언어와 프레임워크를 구분하지 못하는 오해도 종종 발생하는데, 예를 들어 유니티 엔진의 스크립트를 작성하기 위해 C#을
사용하는 것은 맞지만, 유니티 = C# 이 아니다. C#은 당 초 닷넷 프레임워크에서 쓰이기 위해 만들어진 언어이며, 유니티의
C#은 실제로는 Mono위에서 돌아갔었다.[35]
초보자가 기본 문법만 배워도 텍스트 기반은 컴 파일러 또는 기반이 되는 프레임워크나 API 위에서 신나게 돌릴 수 있다. 하지만
프로그래밍에 대해 전혀 모르는 친구에게 "내가 프로그램을 만들었는데 한 번 구경해볼래?" 라고 보여주기 위해서는 각 언어에
해당하는 GUI 프로그래밍[36]을 별도로 익혀야 한다. GUI로 표현이 되지 않은 프로그램은 일반인들로 하여 금 "프로그래머가
--
것이다. 이처럼 프로그래머와 일반인의 시각차는 매우 크기에 오해를 줄이기 위해서는 서로의 노력을 매우 필요로 한다.
또한 초보자들이 많이 하는 오해 중 하나는 '어떤 프로그래밍 언어 = XX를 하기 위한 언어'로 단정짓는 것이다. 대표적인
오해로 JavaS cript는 당시 웹 페이지에서 돌아가도록 만들어진 것이 맞지만, 2022년 현재는 단지 프런트 뿐만 아니라
백엔드나 머신 러닝, 스크 립팅, 웹 브라우저 확장 프로그래밍, GUI 개발, 클라우드 엣지 컴퓨팅 등 광범위한 분야에서 사용된다.
물론 실제 언어의 사용자층이나 생태계에 따라 '특정 분야에서 더욱 유리한 ' 언어가 있는 것도 사실이고 실제로 아예 특수 목적
용도로만 쓰이는 언어(SQL, R 등)가 있기도 하니 주의.
반대 경우로 여러 언어를 대충 배우고서 그것을 자신의 지식으로 착각하는 경우도 존재하는데, 상술했듯이 언어의 문법을 배우는 것은
해당 분야의 가장 기초적인 관문이다. 즉, 해당 언어 생태계에 익숙하지 못하다면 '자신이 생각하는 속도 그대로' 코드를 짤 수
없으며, 냄새나는 코드를 찾아낼 능력도 떨어지고, 그런 코드를 리팩토링할 수 있는 능력은 더더욱 떨어지며, 심지어는 남의 코드를
거의 읽지 못하거나 더욱 심하게는 자신이 쓴 코드도 읽어내지 못한다.[37]
비슷한 경우로 한 언어(주로 C++)에 대한 책(또는 강의)을 모두 읽었다고 언어를 모두 익혔다고 착각하는 경우가 있다. 예를
들어 XX 언어에 대한 책을 며칠 만에 떼겠다고 계획을 세우는 경우가 있다. 다른 분야와는 다르게 프로그래밍 관련 서적은 하나의
책을 사전(reference)처럼 쓰는 것이 좋으며 [38], 따라서 한 책을 (부분적으로) 10번 넘게 읽게 되는 경우도
흔하다. 이는 비단 책에만 한정되는 것이 아니며, 부트 캠프 광고에서 흔히 볼 수 있는 'X 언어 100시간 완성' 따위의
캐치프레이즈는 실제론 말도 안 된다는 것을 알 수 있다. 단적으로 외국인을 대상으로 하는 한국어 강의에 '한국어 100시간
완성 ' 같은 제목을 쓴다면 코 웃음밖에 더 나오겠는가?
결국 자신이 수십 가지 언어를 모두 잘 안다고 말하는 사람은 자신의 신뢰를 스스로 떨어뜨리는 셈이 되며, 실제로도 각 언어를
입문자만도 못하는 경우가 비일비재하다. 여러 언어를 (=폴리글롯) 능숙하게 사용하는 것은 분명 효율적이지만, 만약 실제로 여러
언어를 배우 고 싶다면 2, 3개 정도만 골라서 집중적으로 배우 고 연습하는 것이 미래에 더욱 도움이 된다.
프로그래밍 언어마다 공통되는 개념이 존재하는 경우가 상당히 많지만, 그렇지 않은 경우 또한 존재한다. 대표적으로 파이썬
학습자들이 반드시 짚고 넘어가는 '일급 함수'[39] 라는 개념은 다른 수많은 언어들에도 존재하는데, C 언어처럼 객 체지 향이 아닌
언어에서는 그 개념조차 존재하지 않는 경우도 있다. 그렇다고 해서 C 언어나 포인터 문법을 두고 이 세상에 필요 없는 언어나
문법이라고 생각하는 사람 또한 없을 것이다. 여러 가지 언어를 알고 있다는 건 언어의 차이를 이해하고 강점, 단점을 명확히
파악하는 것에 있어 도움을 준다. 그리고 새로운 언어를 배울 적에도 자신이 이 미 알고 있는 개념을 대입하여, 문법만 새로 배우면
나머지 또한 쉽게 배우는 접근성조차 향상시킬 수 있어 도움이 된다. 다만 그것이 절대적인 실력의 척도 가 되지 못함 또한 분명하게
--

* The PYPL Popul aritY of Programming Language Index에서 프로그래밍 언어 인기 순위를
볼 수 있다. 2023년 11월 기준 Python이 1위, Java이 2위, JavaS cript가 3위이다.
* TIO(Try It Online)에서는 난해 한 프로그래밍 언어까지 포함하여 많은 프로그래밍 언어를 온라인에서 돌려볼 수
있다.
--

* 프로그래밍 언어/예제 (분류에서 보기)
* 프로그래밍 언어 문법

프로그래밍 언어 문법

--

프로그래밍 언어 문법
C(포인터 · 구조체 · size_t) · C++(자료형 · 클래스 · 이름 공간 · 상수 표현식 · 특성) · C# · Java
--
· Haskell(모나드)
마크업 언어 문법
HTML · CSS
--

프로그래밍 언어 목록 · 분류 · 문법 · 예제
[1] 파이썬과 자바스크립트 같은 언어는 스크립트 언어이므로 인터프리터로 실행하면서 해석된다.[2] 괴델이 고안 한 윈시 재귀
함수에서는 중단(termination)이 가정되어 있다. 즉, 무한 루프와 같은 것이 불가능하다(!). 이는 불완전성
--
m u-operator(말 그대로 최소 값을 찾아주는 연산자이다.)를 더하면 class of recurs ive functions로
진화하여 무한 루프 등의 알고리즘을 다 표현할 수 있다.[3] 오늘날 C나 자바 등의 언어에 익숙한 사람들은 이
While-programming이 가장 친숙하게 느껴질 것이다.[4] S, K, I 3개의 함수로 이루어진 언어이다.
튜링-완전이기 때문에 다른 체제와 마찬가지로 모든 알고리즘을 표현하는 것이 가능하며, I는 S와 K로부터 연역되기 때문에 사실상
함수 2개로 이루어진 가장 간단한 수학적 프로그래밍 언어라 할 수 있다.[5] 증명이 아니 기 때문에 정리(theorem) 같은
것이 아닌 명제(thesis)가 붙는다.[6] 이 사람은 수백 년을 앞서 나간 인간이다. 당시 기술력만 되었다면 그 시절에 이미
--
또는 간단하게 이름(name)이라고도 부른다.[9] 특수어(special word)라고도 부른다.[10] 어셈블리어는 바로
컴퓨터가 이해할 수는 없지만 기 계어와 1:1 대응이 되므로 저급 언어다.[11] Sulong을 통해 JVM 바이트 코드로
컴파일 되어 JVM에서 실행되던지, Ems cripten 등으로 WASM으로 컴파일 되어 자바스크립트 VM에서 실행된다[12]
--
Erlang과 Erlang HiPE[15] 이 때문에 Native Language라고 불리기도 한다.[16] 일례로, 사람들이
Java 언어를 AOT 컴파일하면 빨라질 것이라고 착각해, GraalVM으로 AOT 컴파일 한 후에 최초 실행시를 제외하고
전반적으로 더 느려짐에 당황하는 경우가 많다. AOT 컴파일러는 런타임에 JIT 컴파일을 하지 않아도 되기 때문에 실행 직후에
이점이 있을 뿐, 본질적으로 JIT 컴파일러보다 더 적은 정보만으로 최적화를 해야 해서 JIT 컴파일이 끝난 다음의 결과 물을
비교하면 오히려 일반적으로 성능상 떨어진다. # C를 비롯한 대중적인 언어 이외에 깊이 접해보지 못한 사람들이 흔히 하는
착각이라 예시를 들어 서술한다.[17] 대표적인 VM 구현체 : HotSpot, OpenJ9[18] 대표적인 VM 구현체 : V8,
--
언급했듯 JavaS cript는 뭘 지원해줄래야 할 수가 없는 구조이기 때문이다.[27] 이 쪽은 아에 자바처럼 JVM에서의 동작이
고려된 언어다. 프로그래밍 언어와 그 구현체는 별개로 구분되어야 한다는 전형적인 예시 중 하나라고 할 수 있다.[28] 속사정은
상관없이 결과 만 나오면 된다.[29] 각자 따로 자생하며 논다.[30] 파생 상품을 비교적 쉽게 만들 수 있다.[31] C의
#define을 상상하면 된다. s cope 안에서 '= '로 정의된 변수들은 아무 생각 없이 우항으로 대체 하는 것이 가능하다.
명령형 언어에서는 다시 대입되어 수정될 수 있기 때문에 불가능하다.[32] 이 시각이 극명하게 드러난 예가 바로 Tell,
Don 't Ask(TDA ; 묻지 않고 시키기) 원칙이며, 그 구현이 바로 람 다식이다.[33] Palm löf, Otto.
"Wittgenstein and the Chinese Room." (2023). (영어 원문, 한국어 번역)[34] 최근에는
풀스택 프레임워크의 비효율성을 지적하여 아예 마이크로 프레임워크를 중심으로 가르치는 강의 등도 존재한다. 풀스택과 마이크로 모두
--
데스크 탑용 UI라이브러리, 모바일 앱, 프런트 엔드 뷰, OpenGL 등의 그래픽 라이브러리, Plot* 등 시각화 라이브러리
등[37] 쉽게 비유해 '봉주르'를 말할 줄 안다고 프랑스인과 자연스럽게 수다를 떨 수는 없는 것과 마찬가지이다. 언어의 문법과
함께 어휘, 청해, 숙어 그리고 실제 연습이 뒷받침되지 않는다면 실제 언어를 구사하기까지는 많은 시간이 걸린다.[38] 온라인
문서도 마찬가지다. 프로그래밍은 언어, 프레임워크, CLI 툴 등 종류를 막론하고 늘 방대한 분량의 매뉴얼이 필요하다.[39]
함수형 언어들의 람다와 비슷하면서도 미묘하게 다른 개념이다. 정확히는 람다는 이름을 가지고 있지 않는,
표현식(express ion)으로 생성되는 함수이며 일급 함수는 기본 값(prim itive types) 과 똑같이 변수에 저장하거나
