   #Android Developers alternate alternate alternate alternate alternate
   alternate alternate alternate alternate alternate alternate alternate
   alternate alternate alternate alternate alternate alternate alternate
   alternate alternate alternate

   (BUTTON)
   Android Developers
     *

   Essentials
     * Android 스튜디오의 Gemini
     * Android 개발을 위한 AI 개발의 동반자입니다.
     * 자세히 알아보기
     * Android 스튜디오 다운로드

     * 시작하기
     * 첫 번째 앱을 만들어 시작해 보세요. 교육 과정을 자세히 살펴보거나 직접 앱 개발을 탐색해 보세요.
     * Hello World
     * 교육 코스
     * 튜토리얼
     * Android용 Kotlin
     * Play를 통한 수익 창출 ↗️

     * 기기별 확장
     * 휴대전화에서 태블릿, 시계, 헤드셋 등에 이르기까지 원활한 환경을 사용자에게 제공하는 앱을 빌드하세요.
     * Android XR
     * Wear OS
     * 자동차용 Android
     * Android TV
     * ChromeOS
     * 어시스턴트

     * 카테고리별로 빌드
     * Google의 규정적이고 독보적인 지침에 따라 사용 사례에 맞게 빌드하는 방법을 알아보세요.
     * 게임
     * 카메라 및 미디어
     * 소셜 및 메시지
     * 건강/운동
     * 생산성
     * 기업용 앱

     * 최신 뉴스 확인
     * 일 년 내내 최신 버전을 체험하고, 미리보기 프로그램에 참여하고, 의견을 보내주세요.
     * 최신 업데이트
     * 실험 버전 업데이트
     * Android 스튜디오 미리보기
     * Jetpack 및 Compose 라이브러리
     * Wear OS 미리보기
     * 개인 정보 보호 샌드박스

   디자인 및 계획
     * UI 디자인
     * Android 권장사항을 사용하여 멋진 사용자 인터페이스를 디자인하세요.
     * Android용 디자인
     * 모바일
     * Android XR
     * 위젯
     * Wear OS
     * Android TV

     * 아키텍처
     * 강력하고 테스트와 유지관리가 쉬운 앱 로직과 서비스를 디자인하세요.
     * 소개
     * 라이브러리
     * 탐색
     * 모듈화
     * 테스트

     * 품질
     * 앱 품질을 계획하고 Play 스토어 가이드라인을 준수하세요.
     * 개요
     * 핵심 가치
     * 사용자 환경
     * 기술 품질
     * 보안

     * 보안
     * 위협으로부터 사용자를 보호하고 안전한 Android 환경을 보장하세요.
     * 개요
     * 개인 정보 보호
     * ID
     * 사기 예방

     * 수십억 사용자를 위한 앱 빌드
     * 보급형 기기를 위한 최고의 환경을 만드세요.
     * 개요
     * 신규 시장 정보
     * Android(Go 버전)

   개발
     * AI 환경 빌드
     * Gemini API 등을 사용해 AI 기반 Android 앱을 빌드하세요.
     * 시작하기

     * 핵심 영역
     * 필요한 기능에 관한 샘플과 문서를 가져옵니다.
     * 샘플
     * 빠른 가이드ᵇᵉᵗᵃ 사용해 보기
     * 사용자 인터페이스
     * 백그라운드 작업
     * 모든 핵심 영역 ⤵️

     * 도구 및 워크플로
     * IDE를 사용하여 앱을 작성 및 빌드하거나 자체 파이프라인을 만듭니다.
     * 코드 작성 및 디버그
     * 프로젝트 빌드
     * 앱 테스트
     * Performance
     * 명령줄 도구
     * Gradle 플러그인 API

     * 기기 기술
     * 폼 팩터용 코드를 작성합니다. 기기를 연결하고 데이터를 공유하세요.
     * 대형 화면(예: 태블릿)
     * Wear OS
     * Android XR
     * Android Health
     * 자동차용 Android
     * Android TV

     * 라이브러리
     * 모든 세부정보가 포함된 API 참조 문서를 둘러보세요.
     * Android 플랫폼
     * Jetpack 라이브러리
     * Compose 라이브러리
     * Google Play 서비스 ↗️
     * Google Play SDK 색인 ↗️

   Google Play 커뮤니티
   (BUTTON)
   ____________________
   /
   (BUTTON)
     * English
     * Deutsch
     * Español – América Latina
     * Français
     * Indonesia
     * Italiano
     * Polski
     * Português – Brasil
     * Tiếng Việt
     * Türkçe
     * Русский
     * עברית
     * العربيّة
     * فارسی
     * हिंदी
     * বাংলা
     * ภาษาไทย
     * 中文 – 简体
     * 中文 – 繁體
     * 日本語
     * 한국어

   Android 스튜디오 로그인
     * Get started
     * Kotlin

   개요 더 나은 앱 빌드 샘플 가이드 개발자 스토리

   ____________________

   (BUTTON)
   Android Developers
     *

     * Essentials
          + 더보기
          + 개요
          + 더 나은 앱 빌드
          + 샘플
          + 가이드
          + 개발자 스토리
     * 디자인 및 계획
          + 더보기
     * 개발
          + 더보기
     * Google Play
     * 커뮤니티
     * Android 스튜디오

     * Kotlin 최초의 Android 개발
     * Android와 Kotlin 기초부터 배우기
          + Compose 사용 시 알아야 하는 Android 기본사항
          + Kotlin 언어 배우기
          + Android에서 일반적인 Kotlin 패턴 사용
          + Kotlin 스타일 가이드
          + 추가 리소스
     * Android Java 개발자를 위한 Kotlin
          + 기존 앱에 Kotlin 추가
          + Kotlin-자바 상호 운용성 가이드
          + 자바 개발자를 위한 Kotlin 알아보기
          + Android에서 Kotlin 사용하기 FAQ
          + Android KTX
               o 개요
               o KTX 확장 목록
          + 추가 리소스
     * 고급 Kotlin 가이드
          + Kotlin 코루틴
               o 코루틴 소개
               o 고급 코루틴 개념
               o 코루틴 테스트
               o 코루틴 권장사항
               o 추가 리소스
          + Kotlin 흐름
               o 개요
               o 흐름 테스트하기
               o StateFlow 및 SharedFlow
          + Parcelize
          + Kotlin 멀티플랫폼
               o 개요
               o 새 Kotlin 멀티플랫폼 프로젝트 만들기
               o 방
               o SQLite
               o DataStore
          + 인증받기
          + 추가 리소스
     * 팀에 Kotlin 도입
          + 대규모 팀에 Kotlin 채택
          + 개발자 스토리

     * Android 스튜디오의 Gemini
     * 자세히 알아보기
     * Android 스튜디오 다운로드
     * 시작하기
     * Hello World
     * 교육 코스
     * 튜토리얼
     * Android용 Kotlin
     * Play를 통한 수익 창출 ↗️
     * 기기별 확장
     * Android XR
     * Wear OS
     * 자동차용 Android
     * Android TV
     * ChromeOS
     * 어시스턴트
     * 카테고리별로 빌드
     * 게임
     * 카메라 및 미디어
     * 소셜 및 메시지
     * 건강/운동
     * 생산성
     * 기업용 앱
     * 최신 뉴스 확인
     * 최신 업데이트
     * 실험 버전 업데이트
     * Android 스튜디오 미리보기
     * Jetpack 및 Compose 라이브러리
     * Wear OS 미리보기
     * 개인 정보 보호 샌드박스

     * UI 디자인
     * Android용 디자인
     * 모바일
     * Android XR
     * 위젯
     * Wear OS
     * Android TV
     * 아키텍처
     * 소개
     * 라이브러리
     * 탐색
     * 모듈화
     * 테스트
     * 품질
     * 개요
     * 핵심 가치
     * 사용자 환경
     * 기술 품질
     * 보안
     * 보안
     * 개요
     * 개인 정보 보호
     * ID
     * 사기 예방
     * 수십억 사용자를 위한 앱 빌드
     * 개요
     * 신규 시장 정보
     * Android(Go 버전)

     * AI 환경 빌드
     * 시작하기
     * 핵심 영역
     * 샘플
     * 빠른 가이드ᵇᵉᵗᵃ 사용해 보기
     * 사용자 인터페이스
     * 백그라운드 작업
     * 모든 핵심 영역 ⤵️
     * 도구 및 워크플로
     * 코드 작성 및 디버그
     * 프로젝트 빌드
     * 앱 테스트
     * Performance
     * 명령줄 도구
     * Gradle 플러그인 API
     * 기기 기술
     * 대형 화면(예: 태블릿)
     * Wear OS
     * Android XR
     * Android Health
     * 자동차용 Android
     * Android TV
     * 라이브러리
     * Android 플랫폼
     * Jetpack 라이브러리
     * Compose 라이브러리
     * Google Play 서비스 ↗️
     * Google Play SDK 색인 ↗️

   이 페이지는 Cloud Translation API를 통해 번역되었습니다.

     * Android Developers
     * Get started
     * Kotlin
     * 가이드

                              Kotlin 프로그래밍 언어 알아보기

   컬렉션을 사용해 정리하기 내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

   Kotlin은 프로그래밍 언어입니다. 전 세계에서 Android 개발자가 널리 사용합니다. 이 주제는 활용도를 높이기 위한
   Kotlin 단기 집중과정입니다.

변수 선언

   Kotlin은 두 키워드(val 및 var)를 사용하여 변수를 선언합니다.
     * 값이 변경되지 않는 변수에 val을 사용합니다. val을 사용하여 선언된 변수에 값을 재할당할 수 없습니다.
     * 값이 변경될 수 있는 변수에 var을 사용합니다.

   아래 예에서 count는 10의 초기 값이 할당되는 Int 유형의 변수입니다.
var count: Int = 10

   Int는 정수를 나타내는 유형이며 Kotlin에서 표현될 수 있는 많은 숫자 유형 중 하나입니다. 다른 언어와 마찬가지로 수치
   데이터에 따라 Byte, Short, Long, Float, Double을 사용할 수도 있습니다.

   var 키워드는 필요에 따라 count에 값을 재할당할 수 있음을 의미합니다. 예를 들어 count 값을 10에서 15로 변경할
   수 있습니다.
var count: Int = 10
count = 15

   하지만 일부 값은 변경되지 않습니다. languageName이라는 String을 고려합니다. languageName에서
   'Kotlin'의 값이 항상 유지되도록 하려면 val 키워드를 사용하여 languageName을 선언합니다.
val languageName: String = "Kotlin"

   이러한 키워드를 사용하면 변경 가능한 항목을 명시할 수 있습니다. 필요에 따라 키워드를 유용하게 사용하세요. 변수 참조를
   재할당할 수 있어야 하는 경우 var로 선언합니다. 그렇지 않은 경우 val을 사용합니다.

유형 추론

   이전 예에서 languageName에 초기 값을 할당할 때 Kotlin 컴파일러는 할당된 값의 유형을 기반으로 유형을 추론할 수
   있습니다.

   "Kotlin" 값이 String 유형이므로 컴파일러는 languageName 또한 String이라고 추론합니다. Kotlin은
   정적으로 입력되는 언어입니다. 즉, 컴파일 시간에 유형이 결정되고 절대 변경되지 않습니다.

   다음 예에서 languageName이 String으로 추론되므로 String 클래스의 일부가 아닌 함수를 호출할 수 없습니다.
val languageName = "Kotlin"
val upperCaseName = languageName.toUpperCase()

// Fails to compile
languageName.inc()

   toUpperCase()는 String 유형의 변수에서만 호출할 수 있는 함수입니다. Kotlin 컴파일러가
   languageName을 String으로 추론했으므로 toUpperCase()를 안전하게 호출할 수 있습니다. 하지만
   inc()는 Int 연산자 함수이므로 String에서 호출할 수 없습니다. Kotlin의 유형 추론 방식은 간결성과 유형
   안전성을 모두 보장합니다.

Null 안전

   일부 언어에서는 초기 값을 명시적으로 제공하지 않고 참조 유형 변수를 선언할 수 있습니다. 이러한 경우 변수에는 일반적으로
   null 값이 포함됩니다. Kotlin 변수는 기본적으로 null 값을 보유할 수 없습니다. 즉, 다음 스니펫은 유효하지
   않습니다.
// Fails to compile
val languageName: String = null

   null 값을 포함하는 변수는 nullable 유형이어야 합니다. 아래 예와 같이 ?를 변수 유형의 접미사로 지정하여 변수를
   nullable로 지정할 수 있습니다.
val languageName: String? = null

   String? 유형을 사용하여 String 값 또는 null을 languageName에 할당할 수 있습니다.

   nullable 변수는 신중하게 처리해야 합니다. 아니면 심각한 NullPointerException이 발생할 위험이 있습니다.
   예를 들어, 자바에서 null 값에 관해 메서드를 호출하려고 하면 프로그램이 비정상 종료됩니다.

   Kotlin은 nullable 변수로 안전하게 작업하기 위한 많은 메커니즘을 제공합니다. 자세한 내용은 Android의 일반
   Kotlin 패턴: Null 허용 여부를 참조하세요.

조건부

   Kotlin은 조건부 논리를 구현하기 위한 몇 가지 메커니즘을 제공합니다. 가장 일반적인 것은 if-else 문입니다. if
   키워드 옆의 괄호 안에 포함된 표현식이 true로 평가되는 경우, 해당 분기 내 코드(즉, 중괄호 안에 포함된 바로 다음
   코드)가 실행됩니다. 그렇지 않은 경우 else 분기 내 코드가 실행됩니다.
if (count == 42) {
    println("I have the answer.")
} else {
    println("The answer eludes me.")
}

   else if를 사용하여 여러 조건을 나타낼 수 있습니다. 즉, 다음 예와 같이 단일 조건문 내에서 보다 상세하고 복잡한 논리를
   표현할 수 있습니다.
if (count == 42) {
    println("I have the answer.")
} else if (count > 35) {
    println("The answer is close.")
} else {
    println("The answer eludes me.")
}

   조건문은 스테이트풀(Stateful) 논리를 나타내는 데 유용하지만 작성 시 반복될 수 있습니다. 위 예에서는 각 분기에
   String을 인쇄합니다. 이 반복을 피하기 위해 Kotlin은 조건식을 제공합니다. 마지막 예는 다음과 같이 다시 작성될 수
   있습니다.
val answerString: String = if (count == 42) {
    "I have the answer."
} else if (count > 35) {
    "The answer is close."
} else {
    "The answer eludes me."
}

println(answerString)

   암시적으로 각 조건부 분기는 마지막 줄에 표현식의 결과를 반환하므로 return 키워드를 사용할 필요가 없습니다. 세 분기의
   결과는 모두 String 유형이므로 if-else 표현식의 결과도 String 유형입니다. 이 예에서 answerString에는
   if-else 표현식의 결과에서 초기 값이 할당됩니다. 유형 추론을 사용하여 answerString에 명시적 유형 선언을 생략할
   수 있지만 명확히 하기 위해 유형 선언을 포함하는 것이 좋습니다.

   참고: Kotlin에는 기존의 3항 연산자가 없으며 주로 조건식이 대신 사용됩니다.

   아래 예와 같이 조건문의 복잡도가 증가하면 if-else 표현식을 when 표현식으로 교체할 것을 고려할 수 있습니다.
val answerString = when {
    count == 42 -> "I have the answer."
    count > 35 -> "The answer is close."
    else -> "The answer eludes me."
}

println(answerString)

   when 표현식의 각 분기는 조건, 화살표(->) 및 결과로 표시됩니다. 화살표의 왼쪽 조건이 true로 평가되면 오른쪽에 있는
   표현식의 결과가 반환됩니다. 한 분기에서 다음 분기로 실행되지 않습니다. when 표현식 예의 코드는 이전 예의 코드와
   기능적으로 동일하지만 쉽게 읽을 수 있습니다.

   Kotlin의 조건부는 이 언어의 강력한 기능 중 하나인 스마트 변환을 강조합니다. 안전 호출 연산자 또는 null이 아닌
   어설션 연산자를 사용하여 nullable 값을 처리하는 대신 아래 예와 같이 조건문을 사용하여 변수에 null 값 참조가 있는지
   확인할 수 있습니다.
val languageName: String? = null
if (languageName != null) {
    // No need to write languageName?.toUpperCase()
    println(languageName.toUpperCase())
}

   조건부 분기 내에서 languageName은 nullable이 아닌 것으로 간주될 수 있습니다. Kotlin에서는 분기 실행
   조건에 따라 languageName은 null 값을 보유할 수 없으므로 분기 내에서 languageName을 nullable로
   처리할 필요가 없습니다. 이 스마트 변환은 null 검사, 유형 검사 또는 컨트랙트를 충족하는 모든 조건에 적용됩니다.

함수

   하나 이상의 표현식을 함수로 그룹화할 수 있습니다. 결과가 필요할 때마다 동일한 일련의 표현식을 반복하는 대신 함수에 표현식을
   포함한 다음 함수를 호출할 수 있습니다.

   함수를 선언하려면 fun 키워드 뒤에 함수 이름이 오도록 사용합니다. 그런 다음 함수에 사용되는 입력 유형(있는 경우)을
   정의하고 함수에서 반환하는 출력 유형을 선언합니다. 함수의 본문에서는 함수를 호출할 때 호출되는 표현식을 정의합니다.

   이전 예를 기반으로 완성된 Kotlin 함수는 다음과 같습니다.
fun generateAnswerString(): String {
    val answerString = if (count == 42) {
        "I have the answer."
    } else {
        "The answer eludes me"
    }

    return answerString
}

   위 예에서 함수의 이름은 generateAnswerString입니다. 입력 값은 받지 않으며, String 유형의 결과를
   출력합니다. 함수를 호출하려면 함수의 이름 뒤에 호출 연산자(())를 사용합니다. 아래 예에서 answerString 변수는
   generateAnswerString()의 결과에 따라 초기화됩니다.
val answerString = generateAnswerString()

   아래 예와 같이 함수에서는 인수를 입력으로 사용할 수 있습니다.
fun generateAnswerString(countThreshold: Int): String {
    val answerString = if (count > countThreshold) {
        "I have the answer."
    } else {
        "The answer eludes me."
    }

    return answerString
}

   함수를 선언할 때 인수의 개수와 유형을 지정할 수 있습니다. 위 예에서 generateAnswerString()은 Int 유형의
   countThreshold 인수 한 개를 사용합니다. 함수 내에서 이름을 사용하여 인수를 참조할 수 있습니다.

   이 함수를 호출할 때 함수 호출 괄호 안에 인수를 포함해야 합니다.
val answerString = generateAnswerString(42)

함수 선언 단순화

   generateAnswerString()은 매우 간단한 함수입니다. 이 함수는 변수를 선언한 다음 즉시 반환합니다. 아래 예와
   같이 단일 표현식의 결과가 함수에서 반환되는 경우, 함수에 포함된 if-else 표현식의 결과를 직접 반환하여 로컬 변수 선언을
   건너뛸 수 있습니다.
fun generateAnswerString(countThreshold: Int): String {
    return if (count > countThreshold) {
        "I have the answer."
    } else {
        "The answer eludes me."
    }
}

   반환 키워드를 할당 연산자로 바꿀 수도 있습니다.
fun generateAnswerString(countThreshold: Int): String = if (count > countThresho
ld) {
        "I have the answer"
    } else {
        "The answer eludes me"
    }

익명 함수

   모든 함수에 이름이 필요하지는 않습니다. 일부 함수는 입력과 출력에 의해 더 직접적으로 식별됩니다. 이러한 함수를 익명 함수라고
   합니다. 이 참조를 사용하여 나중에 익명 함수를 호출하면 익명 함수 참조를 유지할 수 있습니다. 다른 참조 유형과 마찬가지로
   애플리케이션에서 참조를 전달할 수도 있습니다.
val stringLengthFunc: (String) -> Int = { input ->
    input.length
}

   이름이 지정된 함수와 마찬가지로 익명 함수는 표현식을 제한 없이 포함할 수 있습니다. 함수의 반환 값은 최종 표현식의
   결과입니다.

   위 예에서 stringLengthFunc는 String을 입력으로 사용하고 String 입력 길이를 Int 유형의 출력으로
   반환하는 익명 함수 참조를 포함합니다. 따라서 함수의 유형은 (String) -> Int로 표시됩니다. 하지만 이 코드는 함수를
   호출하지 않습니다. 함수의 결과를 가져오려면 이름이 지정된 함수처럼 호출해야 합니다. 아래 예와 같이
   stringLengthFunc를 호출할 때 String을 공급해야 합니다.
val stringLengthFunc: (String) -> Int = { input ->
    input.length
}

val stringLength: Int = stringLengthFunc("Android")

고차 함수

   함수는 다른 함수를 인수로 취할 수 있습니다. 다른 함수를 인수로 사용하는 함수를 고차 함수라고 합니다. 이 패턴은 자바에서
   콜백 인터페이스를 사용할 때와 동일한 방식으로 구성요소 간에 통신하는 데 유용합니다.

   다음은 고차 함수의 예입니다.
fun stringMapper(str: String, mapper: (String) -> Int): Int {
    // Invoke function
    return mapper(str)
}

   stringMapper() 함수는 전달된 String에서 Int 값을 파생하는 함수와 함께 String를 가져옵니다.

   아래 예와 같이 다른 입력 매개변수를 충족하는 함수, 즉 String을 입력으로 사용하고 Int를 출력하는 함수와 String을
   전달하여 stringMapper()를 호출할 수 있습니다.
stringMapper("Android", { input ->
    input.length
})

   아래 예와 같이 익명 함수가 함수에 정의된 마지막 매개변수인 경우 함수를 호출하는 데 사용된 괄호 밖에서 함수를 전달할 수
   있습니다.
stringMapper("Android") { input ->
    input.length
}

   익명 함수는 Kotlin 표준 라이브러리 전체에서 찾을 수 있습니다. 자세한 내용은 고차 함수 및 람다를 참조하세요.

클래스

   지금까지 언급된 모든 유형은 Kotlin 프로그래밍 언어에 내장되어 있습니다. 아래 예와 같이 맞춤 유형을 추가하려는 경우
   class 키워드를 사용하여 클래스를 정의할 수 있습니다.
class Car

속성

   클래스는 속성을 사용하여 상태를 나타냅니다. 속성은 getter, setter 및 backing 필드를 포함할 수 있는 클래스
   수준 변수입니다. 아래 예와 같이 자동차를 운전하려면 바퀴가 필요하므로 Wheel 객체 목록을 Car의 속성으로 추가할 수
   있습니다.
class Car {
    val wheels = listOf<Wheel>()
}

   wheels는 public val입니다. 즉, Car 클래스 외부에서 wheels에 액세스할 수 있지만 재할당할 수는 없습니다.
   Car의 인스턴스를 가져오려면 먼저 생성자를 호출해야 합니다. 그러면 액세스 가능한 모든 속성에 액세스할 수 있습니다.
val car = Car() // construct a Car
val wheels = car.wheels // retrieve the wheels value from the Car

   바퀴를 맞춤설정하려면 클래스 속성을 초기화하는 방법을 지정하는 맞춤 생성자를 정의하면 됩니다.
class Car(val wheels: List<Wheel>)

   위 예에서 클래스 생성자는 List<Wheel>을 생성자 인수로 취하고 인수를 사용하여 wheels 속성을 초기화합니다.

클래스 함수 및 캡슐화

   클래스는 함수를 사용하여 동작을 모델링합니다. 함수는 상태를 수정할 수 있으므로 노출하려는 데이터만 노출할 수 있습니다. 이
   액세스 제어는 캡슐화라는 더 큰 객체 지향 개념의 일부입니다.

   다음 예에서 doorLock 속성은 Car 클래스 외부의 모든 항목에서 비공개로 유지됩니다. 아래 예와 같이 자동차를 잠금
   해제하려면 유효한 키를 전달하는 unlockDoor() 함수를 호출해야 합니다.
class Car(val wheels: List<Wheel>) {

    private val doorLock: DoorLock = ...

    fun unlockDoor(key: Key): Boolean {
        // Return true if key is valid for door lock, false otherwise
    }
}

   속성을 참조하는 방법을 맞춤설정하려면 맞춤 getter 및 setter를 제공하면 됩니다. 예를 들어 속성의 setter에
   액세스하는 것을 제한하면서 속성의 getter를 노출하려면 setter를 private으로 지정합니다.
class Car(val wheels: List<Wheel>) {

    private val doorLock: DoorLock = ...

    var gallonsOfFuelInTank: Int = 15
        private set

    fun unlockDoor(key: Key): Boolean {
        // Return true if key is valid for door lock, false otherwise
    }
}

   속성과 함수를 조합하여 모든 유형의 객체를 모델링하는 클래스를 만들 수 있습니다.

상호운용성

   Kotlin의 가장 중요한 기능 중 하나는 자바와의 유연한 상호운용성입니다. Kotlin 코드는 JVM 바이트 코드로 컴파일되기
   때문에 Kotlin 코드는 자바 코드로 직접 호출될 수 있으며 그 반대의 경우도 마찬가지입니다. 즉, 기존 자바 라이브러리를
   Kotlin에서 직접 활용할 수 있습니다. 또한 대부분의 Android API는 자바로 작성되어 Kotlin에서 바로 호출할 수
   있습니다.

다음 단계

   Kotlin은 지원이 확대되고 성장세를 이어가고 있는 유연하고 실용적인 언어입니다. 아직 사용해보지 않으셨다면 시도해 보시기
   바랍니다. 다음 단계는 공식 Kotlin 문서를 참고하세요. 신청 방법에 대한 가이드와 Android 앱의 일반적인 Kotlin
   패턴입니다.

   이 페이지에 나와 있는 콘텐츠와 코드 샘플에는 콘텐츠 라이선스에서 설명하는 라이선스가 적용됩니다. 자바 및 OpenJDK는
   Oracle 및 Oracle 계열사의 상표 또는 등록 상표입니다.

   최종 업데이트: 2024-09-12(UTC)

   [[["이해하기 쉬움","easyToUnderstand","thumb-up"],["문제가
   해결됨","solvedMyProblem","thumb-up"],["기타","otherUp","thumb-up"]],[["필요한
   정보가 없음","missingTheInformationINeed","thumb-down"],["너무 복잡함/단계 수가 너무
   많음","tooComplicatedTooManySteps","thumb-down"],["오래됨","outOfDate","thum
   b-down"],["번역 문제","translationIssue","thumb-down"],["샘플/코드
   문제","samplesCodeIssue","thumb-down"],["기타","otherDown","thumb-down"]],[
   "최종 업데이트: 2024-09-12(UTC)"],[],[]]

     * X X
       Follow @AndroidDev on X
     * YouTube YouTube
       Check out Android Developers on YouTube
     * LinkedIn LinkedIn
       Connect with the Android Developers community on LinkedIn

     * More Android
          + Android
          + Android for Enterprise
          + Security
          + Source
          + News
          + 블로그
          + Podcasts
     * Discover
          + Gaming
          + Machine Learning
          + Health & Fitness
          + Camera & Media
          + 개인정보처리방침
          + 5G
     * Android Devices
          + Large screens
          + Wear OS
          + ChromeOS devices
          + Android for cars
          + Android TV
     * Releases
          + Android 15
          + Android 14
          + Android 13
          + Android 12
          + Android 11
          + Android 10
          + Pie
     * Documentation and Downloads
          + Android Studio guide
          + Developers guides
          + API 참조
          + Download Studio
          + Android NDK
     * 지원
          + Report platform bug
          + Report documentation bug
          + Google Play support
          + Join research studies

   Google Developers
     * Android
     * Chrome
     * Firebase
     * Google Cloud Platform
     * All products

     * 개인정보처리방침
     * License
     * Brand guidelines
     * Manage cookies
     * Get news and tips by email Subscribe

     * English
     * Deutsch
     * Español – América Latina
     * Français
     * Indonesia
     * Italiano
     * Polski
     * Português – Brasil
     * Tiếng Việt
     * Türkçe
     * Русский
     * עברית
     * العربيّة
     * فارسی
     * हिंदी
     * বাংলা
     * ภาษาไทย
     * 中文 – 简体
     * 中文 – 繁體
     * 日本語
     * 한국어
