<!DOCTYPE html> <html> <head> <title>Projet PPE1-2024</title> <meta charset="utf-8" /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.2/css/bulma.min.css"> </head> <body> <section class="section" > <div class="container is-max-desktop" > <div class="content" > <h2 class="title" >Concordancier <code>kr-27</code></h2> <table class="table" > <tr><th>Contexte gauche</th><th>Mot</th><th>Contexte droit</th></tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>* 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>FSM · 푸시 다운 · 튜링 머신(폰노이만 구조) · 정규 표현식 · 콘웨이의 생명 게임 · 형식 </td> <td>언어</td> <td></td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td> 이론</td> </tr> <tr> <td>프로그래밍 언어(함수형 언어 · 객 체 지향 프로그래밍 · 증명 보조기) · 메타 프로그래밍 · 유형 이론 · 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>이론 컴퓨터 과학 · 암호학 · 전자공학 · </td> <td>언어</td> <td>학(형태론 · 통사론 · 의 미론 · 화용론 · 음운론) · 인지과학</td> </tr> <tr> <td>데이터베이스 · 프로그래밍 </td> <td>언어</td> <td>{컴파일러(어셈블러 · JIT) · 인터프리터 · 유형 이론 · 파싱 · 링커 · 난해한</td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td> } · 메타데이터 · 기계학습 · 빅데이터 · 폰노이만 구조 · 양자컴퓨터 · 행위자 모델 · 인코딩(유니코드 ·</td> </tr> <tr> <td>공학 </td> <td>언어</td> <td></td> </tr> <tr> <td>수식 · 화학식 · 명제 논리 · 술어 논리 · 프로그래밍 </td> <td>언어</td> <td> · 로 지반 · 링 코스 · 이쓰쿠일 · 도기 보나 · 보아 보무</td> </tr> <tr> <td>예술어/가공의 </td> <td>언어</td> <td></td> </tr> <tr> <td>프로그래밍 사이트 선정 프로그래밍 </td> <td>언어</td> <td> 순위 목록</td> </tr> <tr> <td>스펙트럼 부문 상위 10개 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>직업 부문 상위 10개 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>2024년 Stackoverflow 설문조사 기준 인기 상위 25개 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>2024년 8월 기준 검색어 점유율 상위 20개 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>2024년 8월 기준 검색어 점유율 상위 20개 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td> 목록 · 분류 · 문법</td> </tr> <tr> <td>4.5.1. 명령형 </td> <td>언어</td> <td></td> </tr> <tr> <td>4.5.1.1. 절차적 언어 4.5.1.2. 객체 지향 </td> <td>언어</td> <td></td> </tr> <tr> <td>4.5.2. 선언형 </td> <td>언어</td> <td></td> </tr> <tr> <td>4.5.2.1. 함수형 </td> <td>언어</td> <td>4.5.2.2. 논리 프로그래밍 4.5.2.3. 반응형 프로그래밍</td> </tr> <tr> <td>4.6. 특수 목적 </td> <td>언어</td> <td></td> </tr> <tr> <td>5. 회화 </td> <td>언어</td> <td>와의 관계 6. 개발툴7. 예제</td> </tr> <tr> <td>7.1. 난해한 프로그래밍 </td> <td>언어</td> <td>의 예제</td> </tr> <tr> <td>기계(컴퓨터)에게 명령이나 연산을 시킬 목적으로 설계되어 기계와 의사소통을 할 수 있게 해주는 </td> <td>언어</td> <td>를 뜻한다. 그 결과, 사람이</td> </tr> <tr> <td>원하는 작업을 컴퓨터가 수행할 수 있도록 프로그래밍 </td> <td>언어</td> <td>로 일련의 과정을 작성하여 일을 시킨다. 쉽게 말하면 컴퓨터를 이용하기</td> </tr> <tr> <td>위한 언어이다. 프로그램을 작성하는데 기본이 되고, 이 프로그램은 논리 연산의 집합이기 때문에 수리 </td> <td>언어</td> <td>의 일종으로 보는 시각도</td> </tr> <tr> <td>진행된 데에서 비롯되었다. 그 결과 기계가 이해할 수 있는 언어가 탄생했으며, 바로 이 기계가 계산 가능하고 이해 가능한 </td> <td>언어</td> <td>를</td> </tr> <tr> <td>실행하는 기계로 </td> <td>언어</td> <td>보다 나중에 발명된 것이 바로 현대적 의 미의 컴퓨터이다.</td> </tr> <tr> <td>이 언어들은 사람이 이해하기 쉽게 만든 </td> <td>언어</td> <td>로 실행 전 컴파일러를 통해 기계어로 컴파일 된 후 실행된다.[1]</td> </tr> <tr> <td>역사를 잘 살펴보면 프로그래밍 비스 무리한 것을 만들고 했던 기인들이 종종 등장하지만, 프로그래밍 </td> <td>언어</td> <td>라는 본격적인 개념은 역시</td> </tr> <tr> <td>프로그래밍 언어라 볼 수 있다.(굳이 따지자면 함수형 </td> <td>언어</td> <td>라 할 수 있다.) 그리고, 몇 년 후에 컴퓨터의 아버지라 불리는 앨런</td> </tr> <tr> <td>이렇게 수학 쪽에서 프로그래밍 </td> <td>언어</td> <td>에 대한 개념적인 기초가 닦아지는 동안, 역시 수학자인 폰 노이만은 그것들을 이용하여 실제</td> </tr> <tr> <td>사람이 직접 작성하는 형태의 기계어가 사용되었다. 이 기계어는 항목에서 볼 수 있듯이, 이 쪽 분야에서 가장 원시적인 </td> <td>언어</td> <td>로</td> </tr> <tr> <td>쉬운 </td> <td>언어</td> <td>들이 등장하기 시작하였다.</td> </tr> <tr> <td>초창기에 프로그래밍 </td> <td>언어</td> <td>들은 컴퓨터 성능의 한계로 많은 제약이 따라 붙었고, 어 셈블리어 성격이 어느 정도 남아 있었다. 그럼에도</td> </tr> <tr> <td>조건들도 하나씩 사라지고, 보다 사람이 읽기도 쉽고, 이해하기도 쉽고, 작성하기도 쉬운 프로그래밍 </td> <td>언어</td> <td>들이 속 속 등장하였다.</td> </tr> <tr> <td>다만 어차피 컴퓨터가 이해할 수 있는 </td> <td>언어</td> <td>는 기 계어뿐이기 때문에 사람이 하기에 편해졌다는 것 뿐이지 실제 그 뒤에서 이루어지는</td> </tr> <tr> <td>정리하자면, 기계에게 편한 언어는 속도가 빠르지만 사람이 보고 다루기 불편해서 생산성이 떨어진다. 반면 사람에게 편한 </td> <td>언어</td> <td>는</td> </tr> <tr> <td>그러니까 기 계어를 사용한 다 해도 그걸 다루는 프로그래머가 기계의 특성을 훤히 꿰고 있지 않으면 다른 고급 </td> <td>언어</td> <td>를 사용한</td> </tr> <tr> <td>자바 언어를 많이 사용하게 된 이유는 다름 아니라 C 언어의 호환성 때문이라고 한다. C 언어의 단점이 유닉스에서 C </td> <td>언어</td> <td>로 만든</td> </tr> <tr> <td>된다는 거다. 이런 호환성 문제를 해결한 언어가 자바다 보니, 자바 </td> <td>언어</td> <td>를 많이 사용하게 됐다고 한다.[7]</td> </tr> <tr> <td>여담으로 난해한 프로그래밍 </td> <td>언어</td> <td>보다는 어 셈블리어가 훨씬 읽기 쉽다...</td> </tr> <tr> <td>프로그래밍 언어의 표기는 구 문론(syntax)과 의 미론(semantics) 두 가지로 이루어진다. 구문이란 것은 </td> <td>언어</td> <td>의 외형적인</td> </tr> <tr> <td>대부분의 일반적인 프로그래밍 언어는 이런 토 큰들이 영어(정확히는 미국식 영어)로 되어 있다. 물론, 창조(프로그래밍 </td> <td>언어</td> <td>)나</td> </tr> <tr> <td>씨앗(프로그래밍 </td> <td>언어</td> <td>) 같은 예외도 있긴 하다.</td> </tr> <tr> <td>* 프로그래밍 </td> <td>언어</td> <td>/종류</td> </tr> <tr> <td>* 한글 프로그래밍 </td> <td>언어</td> <td></td> </tr> <tr> <td>추상화가 거의 되지 않아서 컴퓨터가 이해하기 쉬운 언어를 저급 </td> <td>언어</td> <td>, 고도로 추상화해 사람이 이해하기 쉽지만 컴퓨터가 이해하려면</td> </tr> <tr> <td>복잡한 번역이 필요한 언어를 고급 </td> <td>언어</td> <td>라 한다.</td> </tr> <tr> <td>* 저급 </td> <td>언어</td> <td></td> </tr> <tr> <td>* 고급 </td> <td>언어</td> <td></td> </tr> <tr> <td>+ 위의 두 언어를 제외한 모든 </td> <td>언어</td> <td></td> </tr> <tr> <td>크게 AOT 컴파일 언어, JIT 컴파일 언어, 그리고 인터프리터 언어로 분류할 수 있다. 이 분류는 정확히 말하면 </td> <td>언어</td> <td>의</td> </tr> <tr> <td>분류가 아니라 언어 구현체의 분류로, </td> <td>언어</td> <td> 명세가 어느 한 쪽을 완전히 배제한 형태가 아니거나 다른 특별한 이유가 있지 않는</td> </tr> <tr> <td>이상 대부분의 언어는 이론상 어떤 식으로든 구현 가능하다. 더불어, 산업 현장에서 널리 쓰이는 </td> <td>언어</td> <td>는 기 본적으로 컴 파일 되어</td> </tr> <tr> <td>실행된다고 보면 된다. 아래의 구분은 언어의 대표 구현체를 따른 것이고, 결코 </td> <td>언어</td> <td> 자체의 분류가 아님에 유의할 것. 예를</td> </tr> <tr> <td>들면, C </td> <td>언어</td> <td>라고 항상 AOT 컴파일 되는 것이 아니며 [11], Java라고 항상 JIT 컴파일 되는 것도 아니며 [12],</td> </tr> <tr> <td>OCam l[13]과 Erlang[14] 등의 </td> <td>언어</td> <td>는 아예 기 본 구현체에 둘 다 포함시켜서 배포한다.</td> </tr> <tr> <td>* AOT(Ahead Of Time) 컴파일 언어 : C </td> <td>언어</td> <td>, C++, Rust, 파스칼, Haskell 등이 포함된다.</td> </tr> <tr> <td>나 기도 한다. 일반적으로 C 계열의 언어들의 런타임 퍼포먼스가 좋기 때문에 AOT 컴파일 된 </td> <td>언어</td> <td>들이 근본적으로 다른</td> </tr> <tr> <td>* JIT(Just-In-Time) 컴파일 언어 : 대부분의 언어가 여기에 속한다. Java 및 JVM </td> <td>언어</td> <td>[17],</td> </tr> <tr> <td>JavaS cript 및 WebAssem bly[18], C# 및 CLR 언어[19] 등의 </td> <td>언어</td> <td>들은 기본 구현체가 JIT</td> </tr> <tr> <td>컴파일러이다. 이 </td> <td>언어</td> <td>들은 대부분 바이트코드를 생성하는 1차 컴파일러, 그리고 1차 컴파일러가 생성한 바이트 코드를</td> </tr> <tr> <td>Runtime), CP ython은 1차 컴파일러가 생성한 바이트 코드 파일들을 배포에 활용하지만, 모든 </td> <td>언어</td> <td>가 그런 것은</td> </tr> <tr> <td>아니다. 또한, JIT 구현체는 동일한 </td> <td>언어</td> <td>의 AOT 구현체에 비해 유연성이 높은 경우가 많다. 예를 들면 Java에서는</td> </tr> <tr> <td>* 인터프리터 언어 : 소스 코드를 한 줄 한 줄 읽어 그때 그 때마다 번역해서 수행한다. BASIC이나 셸 같은 </td> <td>언어</td> <td>가 이런</td> </tr> <tr> <td>형태이다. 소스 코드를 한 줄씩 읽어서 수행하기 때문에, 대체로 AOT 컴파일 언어나 JIT 컴파일 </td> <td>언어</td> <td>에 비해 성능이</td> </tr> <tr> <td>마이너 </td> <td>언어</td> <td>들이 인터프리터를 통해 작동한다.</td> </tr> <tr> <td>크게 비관리 언어와 관리 </td> <td>언어</td> <td>로 분류할 수 있다.</td> </tr> <tr> <td>* 비관리 </td> <td>언어</td> <td>(Unmanaged Language) : 동적 할당된 메모리의 해제가 자동으로 이루어지지 않으며, (주로</td> </tr> <tr> <td>포인터를 이용한) 메모리 직접 접근이 가능한 </td> <td>언어</td> <td>이다. Bare Metal Language라고도 하며, 대표적으로는 C,</td> </tr> <tr> <td>생각하면 그렇기 때문에 메모리 관리를 제대로 하지 않을 시 프로그램이 망가질 가능성이 커서 관리 </td> <td>언어</td> <td>에 비하면 생산성은</td> </tr> <tr> <td>* 관리 </td> <td>언어</td> <td>(Managed Language) : 동적 할당된 메모리의 해제가 가비지 컬렉터(Garbage</td> </tr> <tr> <td>차단한다. 대표적으로는 Java, C#, Python, Go 등이 있다. 메모리 관리를 </td> <td>언어</td> <td> 차원에서 책임져 주기 때문에</td> </tr> <tr> <td>상대적으로 생산성은 높지만, 메모리에 직접 액세스할 수 없으므로 비관리 </td> <td>언어</td> <td>에 비해 성능 면에서 손실이 있다.</td> </tr> <tr> <td>* 정적 타입 언어 : 자료형(Type)이 고정돼 있는 </td> <td>언어</td> <td>. C, C++, Java, C# 등이 여기에 해당된다.</td> </tr> <tr> <td>* 동적 타입 언어 : 타입이 실행 시간에 결정되는 </td> <td>언어</td> <td>. 실행하기 전까지는 특정 식의 타입을 알 수 없다. Python,</td> </tr> <tr> <td>동작하게 되어 있다. 이런 개념은 "덕-타이핑"이라고 하고 동적 타입만의 특성은 아니며 정적 타입 </td> <td>언어</td> <td>에서도 구현이 가능하다.</td> </tr> <tr> <td>단지 정적 타입 </td> <td>언어</td> <td>들이 추구하는 방향이 덕 타이핑과 맞지 않는 경우가 많기 때문에 잘 안 쓸 뿐이다.</td> </tr> <tr> <td>동적 타입 언어 중에서 자바스크립트는 암시적으로 자료형을 마구 변환해주지만 기능보다는 설계 결함으로 간주된다. 정적 타입 </td> <td>언어</td> <td></td> </tr> <tr> <td>정적 타입 </td> <td>언어</td> <td>가 별 거 아닌 것처럼 느껴질 수도 있지만 실은 프로그래머들을 짜증나게 하는 주범이 바로 형 변환(Type</td> </tr> <tr> <td>casting)이기 때문에 동적 타입 언어는 이런 점에서 매우 강점을 가진다. 특히 객체 지향 </td> <td>언어</td> <td>에서는 동적 타입 및 그것의</td> </tr> <tr> <td>닭이라는 타입이 있고 둘 다 날아오르는 기능이 있다면 정적 타입 </td> <td>언어</td> <td>에서는 상위 인터페이스를 추출하는 등의 부가 작업이 필요한데</td> </tr> <tr> <td>덕 타이핑을 지원하는 </td> <td>언어</td> <td>에서는 그냥 넣어버리면 알아서 난다. 물론 단점도 있는데 고래 같이 못 나는 타입을 집어 넣으면</td> </tr> <tr> <td>실행시간 오류(런타임 에러)를 뱉어버린다는 것이었지만 정적 타입 </td> <td>언어</td> <td>는 이런 문제가 없다고 알려져 있지만 거짓말이고 정적 타입</td> </tr> <tr> <td></td> <td>언어</td> <td>도 닭은 닭인데 통닭 같이 못 나는 타입을 집어넣는 바람에 (기술적으로는 해당 메서드가 구현이 안 된 객체) 런타임 에러가 나올</td> </tr> <tr> <td>그러나 이건 현실을 전부 고려하지 않은 반쪽짜리 시각이고, 요즘은 정적 타입 언어가 동적 타입 </td> <td>언어</td> <td>보다 훨씬 생산적이고 오류가</td> </tr> <tr> <td>날 가능성을 줄여준다는 점이 정설로 굳어지고 있으며, 코딩 경력이 주니어만 넘어가더라도 프로그래머가 정적 </td> <td>언어</td> <td>를 선호하는 경향이</td> </tr> <tr> <td>눈에 띄게 늘어난다. 당장 동적 타입 </td> <td>언어</td> <td>로 유명한 파이썬과 자바스크립트[24]가 정적 타입으로 옮겨가려는 움직임을 보이는</td> </tr> <tr> <td>개발을 하려고 할 때 더 흔히 일어나는 문제들이다. 강하고 안전한 정적 타입 시스템을 지원하는 </td> <td>언어</td> <td>는 대부분의 일상적 프로그래밍</td> </tr> <tr> <td></td> <td>언어</td> <td>는 그 어떤 쓰레기 값을 인자로 사용해서 호출해도, 심지어 아예 인자의 갯수마저 틀려버려도 그 호출 코드를 런 타임에 아무</td> </tr> <tr> <td>의심 없이 실행해버리고 예상치 못한 동작을 하며 디버깅에 애를 먹이기 일쑤다. 하지만 정적 타입 </td> <td>언어</td> <td>는 잘못된 호출을 하고 있다고</td> </tr> <tr> <td>컴파일 시에 오류를 친절히 알려준다[25]. 하스켈을 비롯한 강-정적 타입 </td> <td>언어</td> <td> 사용자들이 "컴파일이 된다면 버그는 없다"고 하는</td> </tr> <tr> <td>참고로 하스켈(Haskell)은 정적 타입 </td> <td>언어</td> <td>다. 그런데도 하스켈 코드에는 형 변환 연산자가 없다. 이게 어찌된 일이냐 하면</td> </tr> <tr> <td>하스켈 언어는 정적 타입 언어이지만 강력한 타입 추론 기능을 내장하고 있어 형 변환을 </td> <td>언어</td> <td> 차원에서 자동으로 해 준다. 동적 타입</td> </tr> <tr> <td></td> <td>언어</td> <td> 역시 자동 형 변환을 제공하는데 무슨 차이가 있냐면 그 형 변환을 런 타임에 하느냐 컴파일 타임에 하느냐의 차이다. 즉 버그가</td> </tr> <tr> <td>함수형 언어에만 도입할 수 있는 건 아니므로 신형 설계가 적용된 언어라면 명령형, 객 체 지향 </td> <td>언어</td> <td>라도 타입 추론을 할 수 있다.</td> </tr> <tr> <td>단지 정적 타입 </td> <td>언어</td> <td>로 유명한 C나 자바에 타입 추론 엔진이 없을 뿐이고, C#이나 Kotlin[27] 등의 고 생산성 정적 타입</td> </tr> <tr> <td></td> <td>언어</td> <td>들은 얼마든지 타입 추론을 지원하고 있다. 여기서 타입 추론은 묵 시적 형 변환과 동의 어가 아니다. 겉으로 보이는 건 묵 시적</td> </tr> <tr> <td>불리는데, 명령형 </td> <td>언어</td> <td> 중에서는 Rust가 이를 적용했었다.(현재는 아님.)</td> </tr> <tr> <td>4.5.1. 명령형 </td> <td>언어</td> <td>[편집]</td> </tr> <tr> <td>명령형 언어(Imperative Language)는 프로그램이 어떻게 작업을 수행할지를 표현하는 프로그래밍 </td> <td>언어</td> <td>이다. C,</td> </tr> <tr> <td>Java, C++, Fortran 등의 언어가 여기에 속한다. 명령형 언어는 다시 절차적 언어와 객 체 지향 </td> <td>언어</td> <td>로 나뉜다.</td> </tr> <tr> <td>4.5.1.1. 절차적 </td> <td>언어</td> <td>[편집]</td> </tr> <tr> <td>프로그래밍 언어. 대표적인 언어는 C와 Pas cal. 종종 객 체지향 언어의 상대적 개념으로 절차 지향 </td> <td>언어</td> <td>란 말을 쓰기도</td> </tr> <tr> <td>하는데, 이는 객 체지 향 </td> <td>언어</td> <td>가 등장한 이후에 나타난 것으로 보인다. 이름의 절차는 '명령이 순차적으로 실행되어야 함'을 지칭하는</td> </tr> <tr> <td>애초에 C++나 Java 등의 객 체지 향 언어가 널리 알려지기 전에는 C 나 Pas cal을 절차 지향 </td> <td>언어</td> <td>라고 부르지는 않았다.</td> </tr> <tr> <td>그보다는 구조적 프로그래밍 언어란 말이 C나 Pas cal을 가리키는 말이었다. C++, Java 같은 객 체지 향 </td> <td>언어</td> <td>는 객 체 개념</td> </tr> <tr> <td>구현 자체가 프로그램 언어 개발의 지 향점 중 하나였지만, C 나 Pas cal 등의 언어는 절차 지향을 목표로 개발된 </td> <td>언어</td> <td>가</td> </tr> <tr> <td>아니다. 따라서, 객 체지향을 구현하지 않은 기존 언어를 가리키는 말로 절차 지향 언어보다는 절차적 </td> <td>언어</td> <td>가 적합한 용어 일 것이다.</td> </tr> <tr> <td>4.5.1.2. 객체 지향 </td> <td>언어</td> <td>[편집]</td> </tr> <tr> <td>객체 지향 </td> <td>언어</td> <td>는 프로그래밍을 함에 있어서 데이터와 그 데이터를 처리할 메소드를 한데 묶어 객체를 만들고 객 체들을 조립하는 것을</td> </tr> <tr> <td>목표로 한 언어들을 말한다. 대표적으로 Java와 C++가 여기에 속한다. 객체 지향 </td> <td>언어</td> <td>의 특징은 추상화, 캡슐화, 상속성,</td> </tr> <tr> <td>4.5.2. 선언형 </td> <td>언어</td> <td>[편집]</td> </tr> <tr> <td>선언형 언어(Declarative language)는 명령형 언어와 대비 되는 개념으로, 함수형 </td> <td>언어</td> <td>와 논리 프로그래밍(Logic</td> </tr> <tr> <td>선언형으로 기술하는 가장 유명한 라이브러리로는 제이쿼리(jQuery)가 있으며 앵귤러 JS(A ngul arJS)는 선언형 </td> <td>언어</td> <td>의</td> </tr> <tr> <td>순수 선언형 </td> <td>언어</td> <td>의 특징으로는 참조 투명성(referential transparency)[31]가 꼽힌다.</td> </tr> <tr> <td>또한 선언형 </td> <td>언어</td> <td>에는 '지연 평가(Lazy evalu ation)'라는 강력한 특징이 있다. 계산을 필요한 그 순간이 올 때까지</td> </tr> <tr> <td>미룬다는 개념인데, 이 개념은 선언형 언어에만 있다. 단 선언형 </td> <td>언어</td> <td> 전부가 지연 평가를 지원하는 건 아니다. 이 지연 평가</td> </tr> <tr> <td></td> <td>언어</td> <td>에서는 무한을 대입하면 말 그대로 무한히 계산을 하기 때문에 프로그램이 무한 루프를 돌며 멈춰 버리지만 지연 평가를 지원하는</td> </tr> <tr> <td></td> <td>언어</td> <td>에서는 만 약 계산식의 마지막이 "...해당 리스트의 첫 5개를 출력." 하는 식으로 끝났다면 그 '첫 5개'를 찾아내기 위한</td> </tr> <tr> <td>언어라면 피보나치 수열을 생성하는 알고리즘 자체에 루프를 멈추는 코드를 삽입해야 하지만 지연 평가가 지원되는 선언형 </td> <td>언어</td> <td>의 경우</td> </tr> <tr> <td>선언형 언어가 아니어도 지연 평가를 구현하는 방법이 있긴 하다. 더 티 플래그(dirty flag) 기법이 대표적. 단지 </td> <td>언어</td> <td>에서</td> </tr> <tr> <td>4.5.2.1. 함수형 </td> <td>언어</td> <td>[편집]</td> </tr> <tr> <td>상세 내용 아이콘 자세한 내용은 함수형 </td> <td>언어</td> <td> 문서</td> </tr> <tr> <td>명령형 언어가 튜링 머신에, 함수형 </td> <td>언어</td> <td>가 람 다 대수에 기반하고 있다면 논리 프로그래밍은 수리 논리학의 First ord er</td> </tr> <tr> <td>logic(1차 언어)을 모델로 사용하는 프로그래밍 </td> <td>언어</td> <td>의 총칭이다.</td> </tr> <tr> <td>사실 이 바닥의 알파와 오메가인 Prolog가 1차 </td> <td>언어</td> <td>에 기반하고 있기 때문에 이런 식의 정의가 많이 쓰이지만 실제론</td> </tr> <tr> <td>Higher ord er logic, F-logic, linear logic 등 여러 가지 다른 논리를 사용하는 </td> <td>언어</td> <td>도 있고,</td> </tr> <tr> <td>이것들도 대부분 Prolog에 기반하고 있는 경우가 많아서 다 논리 프로그래밍 </td> <td>언어</td> <td>라 한다.</td> </tr> <tr> <td>Clause의 집합이 곧 프로그램이 되며, Clause는 이 쪽에서 가장 유명한 Prolog </td> <td>언어</td> <td>를 예로 들면 아래와 같은</td> </tr> <tr> <td>사실 일반 프로그래머 눈에 위의 함수형 </td> <td>언어</td> <td>보다 더더욱 괴악해 보이게 마련인데 그래도 튜링 컴플리트이며 C++ 등과 같은</td> </tr> <tr> <td>General purpose </td> <td>언어</td> <td>다.</td> </tr> <tr> <td>함수형 </td> <td>언어</td> <td>에서 프로그램을 함수의 집합으로 보고 있다면 논리 프로그래밍에서는 프로그램을 공리의 집합으로 보고 있다고 이해하면</td> </tr> <tr> <td>명령형 언어와는 거리가 멀지만 함수형 </td> <td>언어</td> <td>와는 의 외로 가까운 편이고 실제 코드도 꽤 비슷한 양상을 띈다.</td> </tr> <tr> <td>실제 코딩시의 함수형 언어와 가장 큰 차이라면 아무래도 함수형 언어가 '함수'를 사용할 때, 논리 프로그래밍 </td> <td>언어</td> <td>에서는</td> </tr> <tr> <td>다만, Prolog는 논리 프로그래밍 언어지만, 순수 선언형 </td> <td>언어</td> <td>는 아니다.</td> </tr> <tr> <td>Mercury라는 순수 선언형 논리 프로그래밍 </td> <td>언어</td> <td>도 있고 스페인에서 팍팍 밀어주는 Ciao도 순수 선언형 서브시스템을</td> </tr> <tr> <td>이쪽 </td> <td>언어</td> <td>들은 Prolog를 제외하면 Prolog를 기반으로 해서 여러 가지 실험적인 확장을 시킨 것들이 많기 때문에 유저</td> </tr> <tr> <td>프로그래밍은 데이터의 흐름 즉 데이터 플로우(Data flow)에 더 관심을 갖는다. 반응형 프로그래밍 </td> <td>언어</td> <td> 중 가장 쉽게 볼</td> </tr> <tr> <td>수 있는 것은 스프레드 시트 프로그램인 엑셀이 있다. 프로그래밍 </td> <td>언어</td> <td>는 모름지기 텍스트 편집기로 작성하는 거라고 따지고 싶다면</td> </tr> <tr> <td>주면 반응형으로 만들 수 있다. 다만 반응형 프로그래밍을 직접 지원하는 </td> <td>언어</td> <td>나 라이브러리는 그런 적절한 처리를 자동으로 해</td> </tr> <tr> <td>4.6. 특수 목적 </td> <td>언어</td> <td>[편집]</td> </tr> <tr> <td>* SQL - 관계형 데이터베이스에서 데이터를 조작하기 위해 사용되는 표준 </td> <td>언어</td> <td>로 여러 DBMS에서 지원한다.</td> </tr> <tr> <td>* CUDA - 엔비디아 제 GPU를 제어하는 </td> <td>언어</td> <td>.</td> </tr> <tr> <td>* Prolog - 논리 증명 </td> <td>언어</td> <td></td> </tr> <tr> <td>* Process ing - 그래픽스 처리를 위한 </td> <td>언어</td> <td></td> </tr> <tr> <td>* MATLAB - 공학용 시뮬레이션용 </td> <td>언어</td> <td></td> </tr> <tr> <td>* PHP - 웹 사이트를 만드는 데 특화된 </td> <td>언어</td> <td></td> </tr> <tr> <td>* Verilog, VHDL - 디지털 하드웨어의 설계, 시뮬레이션, 문서화를 위한 </td> <td>언어</td> <td>로, 반응형 프로그래밍에 속한다.</td> </tr> <tr> <td>* Verilog-A - 아날로그 하드웨어 설계를 위한 </td> <td>언어</td> <td></td> </tr> <tr> <td>특수 목적 </td> <td>언어</td> <td>의 특징은 해당 분야에서는 뛰어난 생산성을 보인다는 것이다. 하지만 해당 분야를 벗어나는 순간 개발이</td> </tr> <tr> <td>불가능해지거나 오히려 더 난해해진다. 때문에 이런 </td> <td>언어</td> <td>는 아무도 범용 프로그래밍에 사용하지 않는다. 예를 들어, SQL로는 당장</td> </tr> <tr> <td>모르게 여러 언어를 써가며 개발하게 되며, 보통은 일반 목적 언어(보통 C, Java 등) 하나에 여러 특수 목적 </td> <td>언어</td> <td>를</td> </tr> <tr> <td>물려가며 사용한다. 마크업 언어까지 감안하면 하나의 </td> <td>언어</td> <td>만으로 프로그래밍 하는 일은 초보적인 프로그래밍을 제외하고는 거의 없다고</td> </tr> <tr> <td>5. 회화 </td> <td>언어</td> <td>와의 관계[편집]</td> </tr> <tr> <td>프로그래밍 언어는 소프트웨어 개발이라는 한정된 목적으로 쓰이고, 일 생상활에서는 쓰이지 않는다. 또한 회화 </td> <td>언어</td> <td>보다 문법이</td> </tr> <tr> <td>목적으로 하는 마크업 </td> <td>언어</td> <td>에서도 느낄 수 있는 분위기다.</td> </tr> <tr> <td>하지만 자연어와 프로그래밍 언어의 관계는 상당히 밀 접하다. 그 예로 단어를 소리 단위로 쪼개는 음운론은 프로그래밍 </td> <td>언어</td> <td>로 치면</td> </tr> <tr> <td>옮겨간 것이다. 알 토네리코 시리즈의 휴므 노스어나 Ciel nos urge의 REON-4213처럼 프로그래밍 </td> <td>언어</td> <td>와 자연어를</td> </tr> <tr> <td>즉, 프로그래밍 언어와 자연어는 근본적으로 큰 차이가 없다. 애초에 프로그래밍 </td> <td>언어</td> <td> 역시 기계와의 ' 회화'를 위해 사람이 만들어</td> </tr> <tr> <td>노이만처럼 기계어를 외</td> <td>국어</td> <td> 하듯 구사하는 사람이 많았고, 오늘날에도 언어학과에서 프로그래밍 언어를 가르치기도 한다. 게 다가</td> </tr> <tr> <td>ChatGPT 같은 인공지능 언어 모델이 출현하며 프로그래밍 언어와 자연어 사이의 경계는 더욱 모호해지고 있다. 본래 </td> <td>언어</td> <td></td> </tr> <tr> <td>덤으로 생겨버렸다. 프로그래밍 언어도 본질적으로는 </td> <td>언어</td> <td>라는 것을 보여주는 사례이기도 한데, 사실 자연어 처리 연구가 진척되면서</td> </tr> <tr> <td>말만 익힌다고 끝나는 게 아니라는 점도 회화 언어와 프로그래밍 언어의 공통점이다. 어떤 회화 </td> <td>언어</td> <td>에 충분히 숙달됐더라도 현지</td> </tr> <tr> <td>문화나 관습적 표현, 법규 등을 익혀야 그 언어를 사용하는 현지에서 원활하게 생활할 수 있듯, 프로그래밍 언어 역시 그 </td> <td>언어</td> <td>에</td> </tr> <tr> <td>비트겐슈타인의 '</td> <td>언어</td> <td> 게임'과 연결해 중국어 방의 근본적인 한계를 지적한 논문도 존재한다.[33]</td> </tr> <tr> <td>닌텐도의 일환으로 평가받는 </td> <td>언어</td> <td> 활용은 프로그래밍으로 치면 하드웨어 결함으로 발생한 버그와 유사하다. 더욱 섬뜩한 예로, 잘못된</td> </tr> <tr> <td></td> <td>언어</td> <td> 활용으로 발생하는 갈등은 악성코드와 유사하다.</td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td>론</td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td>론</td> </tr> <tr> <td>상세 내용 아이콘 자세한 내용은 프로그래밍 </td> <td>언어</td> <td>/예제 문서</td> </tr> <tr> <td>7.1. 난해한 프로그래밍 </td> <td>언어</td> <td>의 예제[편집]</td> </tr> <tr> <td>상세 내용 아이콘 자세한 내용은 프로그래밍 언어/예제/난해한 프로그래밍 </td> <td>언어</td> <td> 문서</td> </tr> <tr> <td>프로그래밍 언어에 관해 널리 퍼진 오해 중 하나는, '프로그래밍 언어만 알면 개발을 할 수 있다' 이다. 프로그래밍 </td> <td>언어</td> <td>는</td> </tr> <tr> <td>이름대로 </td> <td>언어</td> <td>일 뿐이다. 즉 도구다. 이 도구를 이용해 유용한 프로그램을 개발하는데 필요한 지식과 기술은 별개로 공부해야 한다.</td> </tr> <tr> <td>한</td> <td>국어</td> <td>를 할 수 있다고 누구나 소설을 쓸 수 있는 게 아니듯이 말이다.</td> </tr> <tr> <td>이는 완전히 틀린 말은 아니지만, 현실적으로 프로그래밍 </td> <td>언어</td> <td>는 '명령'(A일 경우 B를 하라 등)을 추상화할 뿐이며 초보자가</td> </tr> <tr> <td>응용 프로그램(애플리케이션)을 제작하려면 단순히 </td> <td>언어</td> <td>만 배워서 끝이 아니라 적합한 프레임워크, 엔진 등과 여러 작업을 위한</td> </tr> <tr> <td>예를 들어 백엔드 구축을 위해서는 각 </td> <td>언어</td> <td>별 웹 프레임워크가, 2D/3D 게임 개발을 위해서는 게임 엔진이, SSR 렌더링을</td> </tr> <tr> <td>위해서는 템플릿 엔진(Jinja, Pug 등) 또는 관련 서버 사이드 </td> <td>언어</td> <td>(JSP, PHP 등)에 대한 지식이, CSR 렌더링을</td> </tr> <tr> <td>따라서 </td> <td>언어</td> <td>의 문법을 배우는 것은 실제 개발 생태계에서는 단지 기초에 불과 한 과정이지만, 그만큼 초보자들이 가장 먼저 접하는</td> </tr> <tr> <td>부분이며 좌절하기도 쉬운 부분이기에 인터넷에서 자신이 C </td> <td>언어</td> <td>를 안다고 스스로 해커를 자처하는 등의 오해가 흔히 발생하는 것이다.</td> </tr> <tr> <td>마찬가지로 </td> <td>언어</td> <td>와 프레임워크를 구분하지 못하는 오해도 종종 발생하는데, 예를 들어 유니티 엔진의 스크립트를 작성하기 위해 C#을</td> </tr> <tr> <td>사용하는 것은 맞지만, 유니티 = C# 이 아니다. C#은 당 초 닷넷 프레임워크에서 쓰이기 위해 만들어진 </td> <td>언어</td> <td>이며, 유니티의</td> </tr> <tr> <td>프로그래밍에 대해 전혀 모르는 친구에게 "내가 프로그램을 만들었는데 한 번 구경해볼래?" 라고 보여주기 위해서는 각 </td> <td>언어</td> <td>에</td> </tr> <tr> <td>또한 초보자들이 많이 하는 오해 중 하나는 '어떤 프로그래밍 언어 = XX를 하기 위한 </td> <td>언어</td> <td>'로 단정짓는 것이다. 대표적인</td> </tr> <tr> <td>물론 실제 언어의 사용자층이나 생태계에 따라 '특정 분야에서 더욱 유리한 ' </td> <td>언어</td> <td>가 있는 것도 사실이고 실제로 아예 특수 목적</td> </tr> <tr> <td>용도로만 쓰이는 </td> <td>언어</td> <td>(SQL, R 등)가 있기도 하니 주의.</td> </tr> <tr> <td>반대 경우로 여러 언어를 대충 배우고서 그것을 자신의 지식으로 착각하는 경우도 존재하는데, 상술했듯이 </td> <td>언어</td> <td>의 문법을 배우는 것은</td> </tr> <tr> <td>해당 분야의 가장 기초적인 관문이다. 즉, 해당 </td> <td>언어</td> <td> 생태계에 익숙하지 못하다면 '자신이 생각하는 속도 그대로' 코드를 짤 수</td> </tr> <tr> <td>비슷한 경우로 한 언어(주로 C++)에 대한 책(또는 강의)을 모두 읽었다고 </td> <td>언어</td> <td>를 모두 익혔다고 착각하는 경우가 있다. 예를</td> </tr> <tr> <td>들어 XX </td> <td>언어</td> <td>에 대한 책을 며칠 만에 떼겠다고 계획을 세우는 경우가 있다. 다른 분야와는 다르게 프로그래밍 관련 서적은 하나의</td> </tr> <tr> <td>흔하다. 이는 비단 책에만 한정되는 것이 아니며, 부트 캠프 광고에서 흔히 볼 수 있는 'X </td> <td>언어</td> <td> 100시간 완성' 따위의</td> </tr> <tr> <td>캐치프레이즈는 실제론 말도 안 된다는 것을 알 수 있다. 단적으로 외국인을 대상으로 하는 한국어 강의에 '한</td> <td>국어</td> <td> 100시간</td> </tr> <tr> <td>결국 자신이 수십 가지 언어를 모두 잘 안다고 말하는 사람은 자신의 신뢰를 스스로 떨어뜨리는 셈이 되며, 실제로도 각 </td> <td>언어</td> <td>를</td> </tr> <tr> <td>입문자만도 못하는 경우가 비일비재하다. 여러 </td> <td>언어</td> <td>를 (=폴리글롯) 능숙하게 사용하는 것은 분명 효율적이지만, 만약 실제로 여러</td> </tr> <tr> <td></td> <td>언어</td> <td>를 배우 고 싶다면 2, 3개 정도만 골라서 집중적으로 배우 고 연습하는 것이 미래에 더욱 도움이 된다.</td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td>마다 공통되는 개념이 존재하는 경우가 상당히 많지만, 그렇지 않은 경우 또한 존재한다. 대표적으로 파이썬</td> </tr> <tr> <td>학습자들이 반드시 짚고 넘어가는 '일급 함수'[39] 라는 개념은 다른 수많은 언어들에도 존재하는데, C </td> <td>언어</td> <td>처럼 객 체지 향이 아닌</td> </tr> <tr> <td>언어에서는 그 개념조차 존재하지 않는 경우도 있다. 그렇다고 해서 C 언어나 포인터 문법을 두고 이 세상에 필요 없는 </td> <td>언어</td> <td>나</td> </tr> <tr> <td>문법이라고 생각하는 사람 또한 없을 것이다. 여러 가지 언어를 알고 있다는 건 </td> <td>언어</td> <td>의 차이를 이해하고 강점, 단점을 명확히</td> </tr> <tr> <td>파악하는 것에 있어 도움을 준다. 그리고 새로운 </td> <td>언어</td> <td>를 배울 적에도 자신이 이 미 알고 있는 개념을 대입하여, 문법만 새로 배우면</td> </tr> <tr> <td>* The PYPL Popul aritY of Programming Language Index에서 프로그래밍 </td> <td>언어</td> <td> 인기 순위를</td> </tr> <tr> <td>* TIO(Try It Online)에서는 난해 한 프로그래밍 언어까지 포함하여 많은 프로그래밍 </td> <td>언어</td> <td>를 온라인에서 돌려볼 수</td> </tr> <tr> <td>* 프로그래밍 </td> <td>언어</td> <td>/예제 (분류에서 보기)</td> </tr> <tr> <td>* 프로그래밍 </td> <td>언어</td> <td> 문법</td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td> 문법</td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td> 문법</td> </tr> <tr> <td>마크업 </td> <td>언어</td> <td> 문법</td> </tr> <tr> <td>프로그래밍 </td> <td>언어</td> <td> 목록 · 분류 · 문법 · 예제</td> </tr> <tr> <td>[1] 파이썬과 자바스크립트 같은 언어는 스크립트 </td> <td>언어</td> <td>이므로 인터프리터로 실행하면서 해석된다.[2] 괴델이 고안 한 윈시 재귀</td> </tr> <tr> <td>진화하여 무한 루프 등의 알고리즘을 다 표현할 수 있다.[3] 오늘날 C나 자바 등의 </td> <td>언어</td> <td>에 익숙한 사람들은 이</td> </tr> <tr> <td>While-programming이 가장 친숙하게 느껴질 것이다.[4] S, K, I 3개의 함수로 이루어진 </td> <td>언어</td> <td>이다.</td> </tr> <tr> <td>함수 2개로 이루어진 가장 간단한 수학적 프로그래밍 </td> <td>언어</td> <td>라 할 수 있다.[5] 증명이 아니 기 때문에 정리(theorem) 같은</td> </tr> <tr> <td>컴퓨터가 이해할 수는 없지만 기 계어와 1:1 대응이 되므로 저급 </td> <td>언어</td> <td>다.[11] Sulong을 통해 JVM 바이트 코드로</td> </tr> <tr> <td>Java </td> <td>언어</td> <td>를 AOT 컴파일하면 빨라질 것이라고 착각해, GraalVM으로 AOT 컴파일 한 후에 최초 실행시를 제외하고</td> </tr> <tr> <td>비교하면 오히려 일반적으로 성능상 떨어진다. # C를 비롯한 대중적인 </td> <td>언어</td> <td> 이외에 깊이 접해보지 못한 사람들이 흔히 하는</td> </tr> <tr> <td>고려된 언어다. 프로그래밍 </td> <td>언어</td> <td>와 그 구현체는 별개로 구분되어야 한다는 전형적인 예시 중 하나라고 할 수 있다.[28] 속사정은</td> </tr> <tr> <td>명령형 </td> <td>언어</td> <td>에서는 다시 대입되어 수정될 수 있기 때문에 불가능하다.[32] 이 시각이 극명하게 드러난 예가 바로 Tell,</td> </tr> <tr> <td>"Wittgenstein and the Chinese Room." (2023). (영어 원문, 한</td> <td>국어</td> <td> 번역)[34] 최근에는</td> </tr> <tr> <td>등[37] 쉽게 비유해 '봉주르'를 말할 줄 안다고 프랑스인과 자연스럽게 수다를 떨 수는 없는 것과 마찬가지이다. </td> <td>언어</td> <td>의 문법과</td> </tr> <tr> <td>함께 어휘, 청해, 숙어 그리고 실제 연습이 뒷받침되지 않는다면 실제 </td> <td>언어</td> <td>를 구사하기까지는 많은 시간이 걸린다.[38] 온라인</td> </tr> <tr> <td>문서도 마찬가지다. 프로그래밍은 </td> <td>언어</td> <td>, 프레임워크, CLI 툴 등 종류를 막론하고 늘 방대한 분량의 매뉴얼이 필요하다.[39]</td> </tr> <tr> <td>함수형 </td> <td>언어</td> <td>들의 람다와 비슷하면서도 미묘하게 다른 개념이다. 정확히는 람다는 이름을 가지고 있지 않는,</td> </tr> </table> </div> </div> </section> </body> </html>
